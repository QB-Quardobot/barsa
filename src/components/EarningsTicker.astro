---
// Earnings Ticker Component
// Shows how much user could have earned while scrolling
---

<div id="earnings-ticker" class="earnings-ticker" role="status" aria-live="polite">
  <button class="earnings-ticker-btn" type="button" aria-label="Перейти к кнопкам действий">
    <div class="earnings-ticker-content">
      <p class="earnings-label">Столько ты мог бы уже заработать:</p>
      <div class="earnings-amount-wrapper">
        <span class="earnings-currency">$</span>
        <span id="earnings-amount" class="earnings-amount">0</span>
      </div>
      <p class="earnings-hint">на AI-моделях</p>
      <div class="earnings-pulse"></div>
    </div>
  </button>
</div>

<script is:inline>
  // Earnings Ticker Logic with proper cleanup
  (function() {
    // Cleanup registry
    const cleanupFunctions = [];
    
    function registerCleanup(fn) {
      cleanupFunctions.push(fn);
      return () => {
        const index = cleanupFunctions.indexOf(fn);
        if (index > -1) cleanupFunctions.splice(index, 1);
      };
    }
    
    function cleanup() {
      cleanupFunctions.forEach(fn => {
        try { fn(); } catch (e) {}
      });
      cleanupFunctions.length = 0;
    }
    
    // Wait for DOM to be ready
    function init() {
      const ticker = document.getElementById('earnings-ticker');
      const amountEl = document.getElementById('earnings-amount');
      const btn = ticker ? ticker.querySelector('.earnings-ticker-btn') : null;
      
      if (!ticker || !amountEl || !btn) {
        // Retry if DOM not ready yet
        if (document.readyState === 'loading') {
          const cleanupListener = registerCleanup(() => {
            document.removeEventListener('DOMContentLoaded', init);
          });
          document.addEventListener('DOMContentLoaded', () => {
            cleanupListener();
            init();
          });
          return;
        }
        return;
      }
      
      // Run main logic
      startTicker(ticker, amountEl, btn);
    }
    
    function startTicker(ticker, amountEl, btn) {
      let currentAmount = 0;
      let tickInterval = null;
      let isVisible = false;
      let scrollStartTime = null;
      let hasStarted = false;
    
    // Scroll threshold to show ticker
    const SCROLL_THRESHOLD = 300;
    // Amount increment (per tick)
    const AMOUNT_INCREMENT = 50;
    // Tick interval (ms)
    const TICK_INTERVAL = 2000;
    
    // Format number with commas
    function formatAmount(num) {
      return num.toLocaleString('en-US');
    }
    
    // Update display
    function updateDisplay() {
      if (!amountEl) return;
      try {
        amountEl.textContent = formatAmount(currentAmount);
        
        // Pulse animation
        amountEl.classList.add('amount-pulse');
        const pulseTimeout = setTimeout(() => {
          if (amountEl) amountEl.classList.remove('amount-pulse');
        }, 600);
        
        registerCleanup(() => clearTimeout(pulseTimeout));
      } catch (e) {
        // Silently fail if element is gone
      }
    }
    
    // Start counting
    function startCounting() {
      if (tickInterval) return; // Already running
      
      scrollStartTime = Date.now();
      hasStarted = true;
      
      // First tick immediately
      currentAmount += AMOUNT_INCREMENT;
      updateDisplay();
      
      // Then every 2 seconds
      const intervalFn = function() {
        // Check if tab is visible (pause when hidden)
        if (document.hidden) return;
        
        currentAmount += AMOUNT_INCREMENT;
        updateDisplay();
      };
      
      tickInterval = window.setInterval(intervalFn, TICK_INTERVAL);
      
      // Register cleanup for interval
      registerCleanup(() => {
        if (tickInterval) {
          clearInterval(tickInterval);
          tickInterval = null;
        }
      });
    }
    
    // Stop counting
    function stopCounting() {
      if (tickInterval) {
        clearInterval(tickInterval);
        tickInterval = null;
      }
    }
    
    // Show ticker
    function showTicker() {
      if (isVisible) return;
      isVisible = true;
      ticker.classList.add('is-visible');
      startCounting();
    }
    
    // Hide ticker
    function hideTicker() {
      if (!isVisible) return;
      isVisible = false;
      ticker.classList.remove('is-visible');
      
      // Stop counting when hidden
      stopCounting();
    }
    
    // Get scroll position from multiple sources (for Telegram Mini App compatibility)
    const mainContentEl = document.getElementById('main-content') || document.querySelector('main');
    
    function getScrollPosition() {
      // In Telegram Mini App, scroll happens on main-content, not window
      let scrollY = 0;
      
      if (mainContentEl) {
        scrollY = mainContentEl.scrollTop || 0;
      }
      
      // Fallback to window scroll (for regular browsers)
      if (scrollY === 0) {
        scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
      }
      
      // Last fallback: body scroll
      if (scrollY === 0) {
        scrollY = document.body.scrollTop || 0;
      }
      
      return scrollY;
    }
    
    // Scroll handler - hide ticker near bottom buttons
    function handleScroll() {
      const scrollY = getScrollPosition();
      
      // Check if we're near the bottom (where CTA buttons are)
      const scrollContainer = mainContentEl || document.documentElement;
      const maxScroll = mainContentEl 
        ? mainContentEl.scrollHeight - mainContentEl.clientHeight 
        : document.documentElement.scrollHeight - window.innerHeight;
      const distanceFromBottom = maxScroll - scrollY;
      const HIDE_THRESHOLD = 400; // Hide ticker when within 400px of bottom
      
      if (scrollY >= SCROLL_THRESHOLD && distanceFromBottom > HIDE_THRESHOLD) {
        showTicker();
      } else {
        hideTicker();
      }
    }
    
    // Also show on page load if already scrolled (e.g., direct link to section)
    function checkInitialScroll() {
      const scrollY = getScrollPosition();
      const scrollContainer = mainContentEl || document.documentElement;
      const maxScroll = mainContentEl 
        ? mainContentEl.scrollHeight - mainContentEl.clientHeight 
        : document.documentElement.scrollHeight - window.innerHeight;
      const distanceFromBottom = maxScroll - scrollY;
      const HIDE_THRESHOLD = 400;
      
      if (scrollY >= SCROLL_THRESHOLD && distanceFromBottom > HIDE_THRESHOLD) {
        showTicker();
      }
    }
    
    // Page visibility handler (pause when tab is hidden)
    function handleVisibilityChange() {
      if (document.hidden) {
        // Pause counting, but keep ticker visible
        // Interval will skip ticks automatically
      } else if (hasStarted && isVisible) {
        // Resume if ticker is visible
        if (!tickInterval) {
          tickInterval = window.setInterval(function() {
            if (!document.hidden) {
              currentAmount += AMOUNT_INCREMENT;
              updateDisplay();
            }
          }, TICK_INTERVAL);
        }
      }
    }
    
    // Ultra-reliable scroll to CTA buttons - ALWAYS works
    // Uses scrollIntoView as primary method with verification and retry
    function scrollToCTA() {
      // Prevent multiple simultaneous scrolls
      if (scrollToCTA.isScrolling) {
        return;
      }
      scrollToCTA.isScrolling = true;
      
      // Helper to find target with exhaustive fallbacks
      function findTargetElement() {
        const selectors = [
          // Primary: first button in final-cta-section
          '#final-cta-section .btn-video-review',
          '.final-cta-section .btn-video-review',
          '#final-cta-section .final-btn-group a:first-of-type',
          '.final-cta-section .final-btn-group a:first-of-type',
          '#final-cta-section [data-cta]:first-of-type',
          '.final-cta-section [data-cta]:first-of-type',
          // Any button in section
          '#final-cta-section a[href*="how-it-works"]:first-of-type',
          '.final-cta-section a[href*="how-it-works"]:first-of-type',
          '#final-cta-section a:first-of-type',
          '.final-cta-section a:first-of-type',
          // Section as fallback
          '#final-cta-section',
          '.final-cta-section',
          // Last resort
          '[data-cta]:first-of-type'
        ];
        
        for (const selector of selectors) {
          try {
            const el = document.querySelector(selector);
            if (el) {
              const rect = el.getBoundingClientRect();
              // Check if element has dimensions (is rendered)
              if (rect.width > 0 || rect.height > 0 || el.offsetParent !== null) {
                return el;
              }
            }
          } catch (e) {
            continue;
          }
        }
        return null;
      }
      
      // Check if element is visible in viewport
      function isElementInViewport(element, container) {
        if (!element) return false;
        const rect = element.getBoundingClientRect();
        const containerRect = container ? container.getBoundingClientRect() : {
          top: 0,
          bottom: window.innerHeight || document.documentElement.clientHeight
        };
        
        // Element is visible if it's within viewport bounds (with tolerance)
        return rect.top >= containerRect.top - 150 && 
               rect.bottom <= containerRect.bottom + 150;
      }
      
      // Main scroll function with retry
      function performScroll(attempt = 0) {
        const maxAttempts = 6; // More attempts for reliability
        
        // Find target element
        let targetElement = findTargetElement();
        
        // If not found, retry
        if (!targetElement) {
          if (attempt < maxAttempts) {
            setTimeout(() => {
              performScroll(attempt + 1);
            }, 150 * (attempt + 1));
            return;
          }
          // Ultimate fallback: scroll to bottom
          const scrollTo = mainContentEl || window;
          if (mainContentEl) {
            mainContentEl.scrollTo({ top: mainContentEl.scrollHeight, behavior: 'smooth' });
          } else {
            window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' });
          }
          setTimeout(() => { scrollToCTA.isScrolling = false; }, 1500);
          return;
        }
        
        // Pre-reveal elements
        const section = targetElement.closest('.final-cta-section') || 
                       document.getElementById('final-cta-section') ||
                       document.querySelector('.final-cta-section');
        
        if (section) {
          const revealInstance = window.revealInstance;
          if (revealInstance && typeof revealInstance.preRevealToTarget === 'function') {
            revealInstance.preRevealToTarget('.final-cta-section');
          } else {
            section.querySelectorAll('[class*="reveal-fade"]:not(.is-revealed), [class*="reveal-up"]:not(.is-revealed), [class*="reveal-scale"]:not(.is-revealed)').forEach((el) => {
              el.style.transition = 'none';
              el.style.opacity = '1';
              el.style.transform = 'none';
              el.classList.add('is-revealed');
            });
          }
        }
        
        // Wait for layout, then scroll
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            const isMainContent = !!mainContentEl;
            const container = isMainContent ? mainContentEl : null;
            
            // PRIMARY METHOD: scrollIntoView (most reliable)
            try {
              targetElement.scrollIntoView({
                behavior: 'smooth',
                block: 'center', // Center in viewport
                inline: 'nearest'
              });
            } catch (e) {
              // If scrollIntoView fails, use manual scroll
              const rect = targetElement.getBoundingClientRect();
              const viewportHeight = isMainContent ? mainContentEl.clientHeight : window.innerHeight;
              const offset = viewportHeight * 0.35;
              
              if (isMainContent) {
                const scrollTop = mainContentEl.scrollTop + rect.top - offset;
                const maxScroll = mainContentEl.scrollHeight - mainContentEl.clientHeight;
                mainContentEl.scrollTo({
                  top: Math.max(0, Math.min(scrollTop, maxScroll)),
                  behavior: 'smooth'
                });
              } else {
                const scrollTop = (window.pageYOffset || document.documentElement.scrollTop) + rect.top - offset;
                const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
                window.scrollTo({
                  top: Math.max(0, Math.min(scrollTop, maxScroll)),
                  behavior: 'smooth'
                });
              }
            }
            
            // VERIFICATION: Check if element is visible and retry if needed
            let checkCount = 0;
            const maxChecks = 15; // Check for up to 3 seconds (15 * 200ms)
            
            function verifyScroll() {
              checkCount++;
              const isVisible = isElementInViewport(targetElement, container);
              
              if (isVisible) {
                // Success! Element is visible
                scrollToCTA.isScrolling = false;
                return;
              }
              
              // Not visible yet - retry scroll
              if (checkCount < maxChecks) {
                // Try scrollIntoView again (more aggressive)
                try {
                  targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                  });
                } catch (e) {
                  // Manual scroll fallback
                  const rect = targetElement.getBoundingClientRect();
                  const viewportHeight = isMainContent ? mainContentEl.clientHeight : window.innerHeight;
                  const offset = viewportHeight * 0.35;
                  
                  if (isMainContent) {
                    const scrollTop = mainContentEl.scrollTop + rect.top - offset;
                    mainContentEl.scrollTo({
                      top: Math.max(0, Math.min(scrollTop, mainContentEl.scrollHeight - mainContentEl.clientHeight)),
                      behavior: 'smooth'
                    });
                  } else {
                    const scrollTop = (window.pageYOffset || document.documentElement.scrollTop) + rect.top - offset;
                    window.scrollTo({
                      top: Math.max(0, Math.min(scrollTop, document.documentElement.scrollHeight - window.innerHeight)),
                      behavior: 'smooth'
                    });
                  }
                }
                
                // Check again after delay
                setTimeout(verifyScroll, 200);
              } else {
                // Max checks reached - reset flag
                scrollToCTA.isScrolling = false;
              }
            }
            
            // Start verification after initial scroll
            setTimeout(verifyScroll, 300);
            
            // Ultimate fallback: reset after max time
            setTimeout(() => {
              scrollToCTA.isScrolling = false;
            }, 4000);
          });
        });
      }
      
      // Start scroll
      performScroll();
    }
    
    // Initialize scroll flag
    scrollToCTA.isScrolling = false;
    
    // Event listeners - listen to scroll on window AND main content (Telegram compatibility)
    let scrollTimeout = null;
    
    function onScrollEvent() {
      if (scrollTimeout) {
        window.cancelAnimationFrame(scrollTimeout);
      }
      scrollTimeout = window.requestAnimationFrame(function() {
        try {
          handleScroll();
        } catch (e) {
          // Silently fail on scroll errors
        }
      });
    }
    
    // Register scroll listeners with cleanup
    const scrollOpts = { passive: true };
    window.addEventListener('scroll', onScrollEvent, scrollOpts);
    registerCleanup(() => window.removeEventListener('scroll', onScrollEvent, scrollOpts));
    
    // ALSO listen to main content scroll (Telegram Mini App - PRIMARY source)
    if (mainContentEl) {
      mainContentEl.addEventListener('scroll', onScrollEvent, scrollOpts);
      registerCleanup(() => mainContentEl.removeEventListener('scroll', onScrollEvent, scrollOpts));
    }
    
    // Register visibility change listener
    document.addEventListener('visibilitychange', handleVisibilityChange);
    registerCleanup(() => document.removeEventListener('visibilitychange', handleVisibilityChange));
    
    // Register button click listener
    btn.addEventListener('click', scrollToCTA);
    registerCleanup(() => btn.removeEventListener('click', scrollToCTA));
    
    // Initial check
    try {
      handleScroll();
      // Double check after a short delay to catch any layout shifts
      const timeout1 = setTimeout(checkInitialScroll, 100);
      const timeout2 = setTimeout(checkInitialScroll, 500);
      registerCleanup(() => {
        clearTimeout(timeout1);
        clearTimeout(timeout2);
      });
    } catch (e) {
      // Silently fail
    }
    
    // Cleanup on page unload
    const unloadHandler = () => {
      cleanup();
    };
    window.addEventListener('beforeunload', unloadHandler);
    registerCleanup(() => window.removeEventListener('beforeunload', unloadHandler));
  }
    
    // Start initialization
    if (document.readyState === 'loading') {
      const domReadyHandler = () => {
        init();
      };
      document.addEventListener('DOMContentLoaded', domReadyHandler);
      registerCleanup(() => document.removeEventListener('DOMContentLoaded', domReadyHandler));
    } else {
      // DOM already ready, but wait a tick for Astro hydration
      const initTimeout = setTimeout(() => {
        try {
          init();
        } catch (e) {
          // Silently fail
        }
      }, 50);
      registerCleanup(() => clearTimeout(initTimeout));
    }
  })();
</script>

<style>
  .earnings-ticker {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    z-index: 9999;
    opacity: 0;
    transform: translateY(20px) scale(0.9);
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    pointer-events: none;
    will-change: opacity, transform;
  }
  
  @media (max-width: 768px) {
    .earnings-ticker {
      bottom: 1rem;
      right: 1rem;
      max-width: calc(100vw - 2rem);
    }
    
    /* Hide on very small screens near bottom */
    @media (max-height: 700px) {
      .earnings-ticker {
        bottom: 0.5rem;
        right: 0.5rem;
      }
    }
  }
  
  /* Ensure CTA buttons have higher z-index than ticker */
  .final-cta-section,
  .final-btn-group {
    position: relative;
    z-index: 1000 !important;
  }
  
  .earnings-ticker.is-visible {
    opacity: 1 !important;
    transform: translateY(0) scale(1) !important;
    pointer-events: all !important;
    visibility: visible !important;
    display: block !important;
  }
  
  .earnings-ticker-btn {
    position: relative;
    padding: 0;
    margin: 0;
    border: none;
    background: transparent;
    cursor: pointer;
    outline: none;
    /* GPU acceleration - only animate transform */
    transform: translateZ(0);
    will-change: transform;
    transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .earnings-ticker-btn:hover {
    transform: scale(1.05) translateZ(0); /* GPU acceleration */
  }
  
  .earnings-ticker-btn:active {
    transform: scale(0.98) translateZ(0); /* GPU acceleration */
  }
  
  .earnings-ticker-content {
    position: relative;
    padding: 1.5rem 1.75rem;
    background: linear-gradient(135deg, 
      rgba(15, 15, 20, 0.95), 
      rgba(30, 58, 138, 0.4),
      rgba(17, 94, 89, 0.4),
      rgba(15, 15, 20, 0.95)
    );
    background-size: 300% 300%;
    animation: gradientShift 4s ease infinite;
    border: 1px solid rgba(96, 165, 250, 0.4);
    border-radius: 24px;
    box-shadow: 
      0 6px 24px rgba(0, 0, 0, 0.5),
      0 0 0 1px rgba(96, 165, 250, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
    min-width: 220px;
    transform: translateZ(0);
    will-change: transform, box-shadow, border-color;
    transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.25s ease, border-color 0.25s ease;
    overflow: hidden;
  }
  
  @keyframes gradientShift {
    0%, 100% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
  }
  
  .earnings-ticker-btn:hover .earnings-ticker-content {
    border-color: rgba(96, 165, 250, 0.5);
    box-shadow: 
      0 8px 24px rgba(0, 0, 0, 0.6),
      0 0 0 1px rgba(96, 165, 250, 0.2),
      inset 0 1px 0 rgba(255, 255, 255, 0.15);
    transform: translateZ(0); /* GPU acceleration */
  }
  
  .earnings-ticker-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(96, 165, 250, 0.05), rgba(34, 211, 238, 0.05));
    border-radius: 24px;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
  
  .earnings-ticker-btn:hover .earnings-ticker-content::before {
    opacity: 1;
  }
  
  .earnings-label {
    font-size: 0.875rem;
    color: rgba(245, 245, 245, 0.7);
    margin: 0 0 0.5rem 0;
    line-height: 1.4;
    text-align: center;
  }
  
  .earnings-amount-wrapper {
    display: flex;
    align-items: baseline;
    justify-content: center;
    gap: 0.25rem;
    margin: 0.5rem 0;
  }
  
  .earnings-currency {
    font-size: 1.5rem;
    font-weight: 700;
    background: linear-gradient(135deg, #60a5fa, #22d3ee);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    line-height: 1;
  }
  
  .earnings-amount {
    font-size: 2.5rem;
    font-weight: 800;
    background: linear-gradient(135deg, #60a5fa, #22d3ee);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    line-height: 1;
    font-variant-numeric: tabular-nums;
    transition: transform 0.2s ease;
  }
  
  .earnings-amount.amount-pulse {
    animation: amountPulse 0.6s ease;
  }
  
  @keyframes amountPulse {
    0%, 100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.1);
    }
  }
  
  .earnings-hint {
    font-size: 0.75rem;
    color: rgba(245, 245, 245, 0.6);
    margin: 0.5rem 0 0 0;
    text-align: center;
    line-height: 1.3;
  }
  
  .earnings-pulse {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: calc(100% - 4px);
    height: calc(100% - 4px);
    border-radius: 20px;
    background: radial-gradient(circle, rgba(96, 165, 250, 0.15) 0%, transparent 70%);
    animation: pulse 2s ease-in-out infinite;
    pointer-events: none;
    opacity: 0.5;
    z-index: 0;
  }
  
  @keyframes pulse {
    0%, 100% {
      transform: translate(-50%, -50%) scale(1);
      opacity: 0.5;
    }
    50% {
      transform: translate(-50%, -50%) scale(1.1);
      opacity: 0.8;
    }
  }
  
  @media (max-width: 640px) {
    .earnings-ticker {
      bottom: 1.5rem;
      right: 1rem;
      left: auto;
    }
    
    .earnings-ticker-content {
      padding: 1.25rem 1.5rem;
      min-width: 200px;
      border-radius: 16px;
    }
    
    .earnings-amount {
      font-size: 2rem;
    }
  }
  
  @media (max-width: 480px) {
    .earnings-ticker {
      bottom: 1rem;
      right: 0.75rem;
    }
    
    .earnings-ticker-content {
      padding: 1rem 1.25rem;
      min-width: 180px;
    }
    
    .earnings-amount {
      font-size: 1.75rem;
    }
  }
  
  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .earnings-ticker,
    .earnings-ticker-btn,
    .earnings-ticker-content,
    .earnings-amount {
      transition: none;
      animation: none;
    }
    
    .earnings-pulse {
      display: none;
    }
  }
  
  /* Focus styles for accessibility */
  .earnings-ticker-btn:focus-visible {
    outline: 2px solid #60a5fa;
    outline-offset: 4px;
    border-radius: 24px;
  }
</style>
