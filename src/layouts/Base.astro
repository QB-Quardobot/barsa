---
import '../styles/global.css';
import { parseUTMFromURL } from '../lib/utm';

interface Props {
  title: string;
  description?: string;
  image?: string;
}

const { title, description = 'Инновационный продукт для вашего бизнеса', image = '/og.jpg' } = Astro.props;
// Derive origin from Astro.site when provided, otherwise from current URL
const requestUrl = Astro.url.toString();
const origin = (Astro.site ? (Astro.site as URL).origin : new URL(requestUrl).origin);
const fullTitle = `${title} | Product`;

// Get UTM parameters from URL
const url = Astro.url.toString();
const utmParams = parseUTMFromURL(url);
---

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <!-- Primary Meta Tags -->
  <title>{fullTitle}</title>
  <meta name="title" content={fullTitle}>
  <meta name="description" content={description}>
  <meta name="author" content="Product Team">
  <meta name="robots" content="index, follow">
  <meta name="language" content="Russian">
  <link rel="canonical" href={Astro.url.href}>
  <link rel="alternate" hrefLang="ru" href={Astro.url.href}>
  
  <!-- Theme Color -->
  <meta name="theme-color" content="#0a0a0a">
  <meta name="msapplication-TileColor" content="#0a0a0a">
  <meta name="color-scheme" content="dark light">
  <meta name="referrer" content="no-referrer-when-downgrade">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content={Astro.url.href}>
  <meta property="og:title" content={fullTitle}>
  <meta property="og:description" content={description}>
  <meta property="og:image" content={new URL(image, Astro.site || origin).href}>
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:type" content="image/jpeg">
  <meta property="og:site_name" content="Product">
  <meta property="og:locale" content="ru_RU">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content={Astro.url.href}>
  <meta name="twitter:title" content={fullTitle}>
  <meta name="twitter:description" content={description}>
  <meta name="twitter:image" content={new URL(image, Astro.site || origin).href}>
  <meta name="twitter:image:alt" content={fullTitle}>
  
  <!-- Preload Fonts -->
  <link rel="preload" href="/fonts/inter-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-medium.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-bold.woff2" as="font" type="font/woff2" crossorigin>
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="manifest" href="/manifest.webmanifest">
  
  <!-- Performance Hints -->
  <link rel="preconnect" href="https://telegram.org" crossorigin>
  <link rel="dns-prefetch" href="//telegram.org">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- Telegram WebApp API -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <!-- JSON-LD Schema -->
  <script type="application/ld+json" is:inline>{JSON.stringify({
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    name: 'AI Model 2.0',
    url: Astro.url.href,
    inLanguage: 'ru-RU',
    potentialAction: {
      '@type': 'SearchAction',
      target: `${Astro.url.origin}/?q={search_term_string}`,
      'query-input': 'required name=search_term_string'
    },
    publisher: {
      '@type': 'Organization',
      name: 'AI Model 2.0',
      url: Astro.url.origin
    }
  })}</script>
  
  <!-- Pass UTM params to client -->
  <script define:vars={{ utmParams: JSON.stringify(utmParams) }}>
    window.utmParams = utmParams;
  </script>
  
  <!-- Initialize UTM, Telegram WebApp and CTA links (consolidated) -->
  <script is:inline>
    (function() {
      const win = window;
      const doc = document;
      
      // UTM helpers
      const storedUtmKey = 'utm_params';
      const utm = (win.utmParams && typeof win.utmParams === 'object') ? win.utmParams : {};
      if (Object.keys(utm).length) {
        try { sessionStorage.setItem(storedUtmKey, JSON.stringify(utm)); } catch {}
      }

      function getStoredUTM() {
        try { return JSON.parse(sessionStorage.getItem(storedUtmKey) || '{}'); } catch { return {}; }
      }
      function withUTM(url) {
        const params = getStoredUTM();
        if (!Object.keys(params).length) return url;
        try {
          const u = new URL(url);
          Object.entries(params).forEach(([k, v]) => { if (v && !u.searchParams.has(k)) u.searchParams.set(k, v); });
          return u.toString();
        } catch {
          const qs = new URLSearchParams(params).toString();
          return url + (url.includes('?') ? '&' : '?') + qs;
        }
      }

      // Telegram init (if present)
      const tg = win.Telegram?.WebApp;
      if (tg) {
        tg.ready();
        tg.expand();
        tg.enableClosingConfirmation();
        const p = tg.themeParams || {};
        const root = doc.documentElement.style;
        if (p.bg_color) root.setProperty('--tg-theme-bg-color', p.bg_color);
        if (p.text_color) root.setProperty('--tg-theme-text-color', p.text_color);
        if (p.hint_color) root.setProperty('--tg-theme-hint-color', p.hint_color);
        if (p.link_color) root.setProperty('--tg-theme-link-color', p.link_color);
        if (p.button_color) root.setProperty('--tg-theme-button-color', p.button_color);
        if (p.button_text_color) root.setProperty('--tg-theme-button-text-color', p.button_text_color);
        if (p.secondary_bg_color) root.setProperty('--tg-theme-secondary-bg-color', p.secondary_bg_color);
        tg.onEvent('themeChanged', () => location.reload());
        const banner = doc.getElementById('telegram-banner');
        if (banner) banner.style.display = 'none';
      }

      // CTA links
      function setupCTALinks() {
        const isTelegram = !!tg;
        doc.querySelectorAll('a[data-cta]').forEach(link => {
          link.addEventListener('click', function(e) {
            const href = this.getAttribute('href');
            if (!href) return;
            const urlWithUtm = withUTM(href);
            if (isTelegram) {
              e.preventDefault();
              tg.openLink(urlWithUtm);
            } else {
              this.target = '_blank';
              this.rel = 'noopener noreferrer';
              this.href = urlWithUtm;
            }
          });
        });
      }

      function updateLinksOnLoad() {
        if (tg) return;
        const params = getStoredUTM();
        if (!Object.keys(params).length) return;
        doc.querySelectorAll('a[data-cta]').forEach(link => {
          const href = link.getAttribute('href');
          if (href && !href.includes('utm_')) link.setAttribute('href', withUTM(href));
        });
      }

      if (doc.readyState === 'loading') {
        doc.addEventListener('DOMContentLoaded', () => { setupCTALinks(); updateLinksOnLoad(); });
      } else {
        setupCTALinks(); updateLinksOnLoad();
      }
    })();
  </script>
</head>
<body>
  <!-- Skip to main content link for accessibility -->
  <a href="#main-content" class="skip-to-main">
    Перейти к основному содержимому
  </a>
  
  <main id="main-content">
    <slot />
  </main>
  
  <!-- Client-side script consolidated above -->
</body>
</html>

