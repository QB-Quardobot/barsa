---
import '../styles/global.css';
import { parseUTMFromURL } from '../lib/utm';

interface Props {
  title: string;
  description?: string;
  image?: string;
}

const { title, description = 'Инновационный продукт для вашего бизнеса', image = '/og.jpg' } = Astro.props;
// Derive origin from Astro.site when provided, otherwise from current URL
const requestUrl = Astro.url.toString();
const origin = (Astro.site ? (Astro.site as URL).origin : new URL(requestUrl).origin);
const fullTitle = `${title} | Product`;

// Get UTM parameters from URL
const url = Astro.url.toString();
const utmParams = parseUTMFromURL(url);
---

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <!-- Primary Meta Tags -->
  <title>{fullTitle}</title>
  <meta name="title" content={fullTitle}>
  <meta name="description" content={description}>
  <meta name="author" content="Product Team">
  <meta name="robots" content="index, follow">
  <meta name="language" content="Russian">
  <link rel="canonical" href={Astro.url.href}>
  <link rel="alternate" hrefLang="ru" href={Astro.url.href}>
  
  <!-- Theme Color -->
  <meta name="theme-color" content="#0a0a0a">
  <meta name="msapplication-TileColor" content="#0a0a0a">
  <meta name="color-scheme" content="dark light">
  <meta name="referrer" content="no-referrer-when-downgrade">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content={Astro.url.href}>
  <meta property="og:title" content={fullTitle}>
  <meta property="og:description" content={description}>
  <meta property="og:image" content={new URL(image, Astro.site || origin).href}>
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:type" content="image/jpeg">
  <meta property="og:site_name" content="Product">
  <meta property="og:locale" content="ru_RU">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content={Astro.url.href}>
  <meta name="twitter:title" content={fullTitle}>
  <meta name="twitter:description" content={description}>
  <meta name="twitter:image" content={new URL(image, Astro.site || origin).href}>
  <meta name="twitter:image:alt" content={fullTitle}>
  
  <!-- Preload Fonts -->
  <link rel="preload" href="/fonts/inter-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-medium.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-bold.woff2" as="font" type="font/woff2" crossorigin>
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="manifest" href="/manifest.webmanifest">
  
  <!-- Performance Hints -->
  <link rel="preconnect" href="https://telegram.org" crossorigin>
  <link rel="dns-prefetch" href="//telegram.org">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- Telegram Mini App Safe Area Support -->
  <style>
    :root {
      /* Safe area insets from Telegram WebApp */
      --tg-safe-area-inset-top: env(safe-area-inset-top, 0px);
      --tg-safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
      --tg-safe-area-inset-left: env(safe-area-inset-left, 0px);
      --tg-safe-area-inset-right: env(safe-area-inset-right, 0px);
      
      /* Viewport height that accounts for safe areas */
      --tg-viewport-height: 100vh;
      --tg-viewport-stable-height: 100vh;
    }
    
    /* Telegram WebApp specific styles */
    body.tg-webapp {
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
      position: fixed;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      /* Disable text selection for native app feel */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      /* Disable long-press context menu */
      -webkit-touch-callout: none;
    }
    
    /* Main content scrollable area (only in Telegram) */
    body.tg-webapp #main-content {
      width: 100%;
      height: 100vh;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding-top: var(--tg-safe-area-inset-top);
      padding-bottom: var(--tg-safe-area-inset-bottom);
      padding-left: var(--tg-safe-area-inset-left);
      padding-right: var(--tg-safe-area-inset-right);
    }
    
    /* Safe area padding for non-Telegram */
    body:not(.tg-webapp) #main-content {
      padding-top: var(--tg-safe-area-inset-top);
      padding-bottom: var(--tg-safe-area-inset-bottom);
      padding-left: var(--tg-safe-area-inset-left);
      padding-right: var(--tg-safe-area-inset-right);
    }
    
    /* Ensure buttons respect safe areas */
    .btn-capsule,
    button,
    a[data-cta] {
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
  </style>
  
  <!-- Telegram WebApp API - loads synchronously BEFORE inline scripts -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <!-- JSON-LD Schema -->
  <script type="application/ld+json" is:inline>{JSON.stringify({
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    name: 'AI Model 2.0',
    url: Astro.url.href,
    inLanguage: 'ru-RU',
    potentialAction: {
      '@type': 'SearchAction',
      target: `${Astro.url.origin}/?q={search_term_string}`,
      'query-input': 'required name=search_term_string'
    },
    publisher: {
      '@type': 'Organization',
      name: 'AI Model 2.0',
      url: Astro.url.origin
    }
  })}</script>
  
  <!-- Pass UTM params to client -->
  <script define:vars={{ utmParams: JSON.stringify(utmParams) }}>
    window.utmParams = utmParams;
  </script>
  
  <!-- Initialize UTM, Telegram WebApp and CTA links (consolidated) -->
  <script is:inline>
    (function() {
      const win = window;
      const doc = document;
      let tg = null; // Telegram WebApp instance
      
      // UTM helpers
      const storedUtmKey = 'utm_params';
      const utm = (win.utmParams && typeof win.utmParams === 'object') ? win.utmParams : {};
      if (Object.keys(utm).length) {
        try { sessionStorage.setItem(storedUtmKey, JSON.stringify(utm)); } catch {}
      }

      function getStoredUTM() {
        try { return JSON.parse(sessionStorage.getItem(storedUtmKey) || '{}'); } catch { return {}; }
      }
      function withUTM(url) {
        const params = getStoredUTM();
        if (!Object.keys(params).length) return url;
        try {
          const u = new URL(url);
          Object.entries(params).forEach(([k, v]) => { if (v && !u.searchParams.has(k)) u.searchParams.set(k, v); });
          return u.toString();
        } catch {
          const qs = new URLSearchParams(params).toString();
          return url + (url.includes('?') ? '&' : '?') + qs;
        }
      }

      // Initialize Telegram WebApp
      function initTelegramWebApp() {
        console.log('[TG-Init] Function called');
        tg = win.Telegram?.WebApp;
        if (!tg) {
          console.log('[TG-Init] WebApp not available - running in browser');
          return false;
        }
        
        console.log('[TG-Init] Found WebApp v' + tg.version + ' on ' + tg.platform);
        console.log('[TG-Init] Current state: isExpanded=' + tg.isExpanded + ', isFullscreen=' + tg.isFullscreen);
        
        // Initialize app
        console.log('[TG-Init] Calling ready()...');
        tg.ready();
        
        console.log('[TG-Init] Calling expand()...');
        tg.expand();
        
        console.log('[TG-Init] Calling enableClosingConfirmation()...');
        tg.enableClosingConfirmation();
        
        // Bot API 7.7+: Disable vertical swipes to prevent accidental closing
        if (typeof tg.disableVerticalSwipes === 'function') {
          console.log('[TG-Init] Calling disableVerticalSwipes()...');
          tg.disableVerticalSwipes();
          console.log('[TG-Init] After disableVerticalSwipes: isVerticalSwipesEnabled=' + tg.isVerticalSwipesEnabled);
        } else {
          console.warn('[TG-Init] disableVerticalSwipes not available');
        }
        
        // Bot API 8.0+: Request fullscreen mode
        if (typeof tg.requestFullscreen === 'function') {
          console.log('[TG-Init] Calling requestFullscreen()...');
          try {
            tg.requestFullscreen();
            console.log('[TG-Init] After requestFullscreen: isFullscreen=' + tg.isFullscreen);
          } catch (err) {
            console.error('[TG-Init] Fullscreen error:', err);
          }
        } else {
          console.warn('[TG-Init] requestFullscreen not available');
        }
        
        // Apply theme
        const p = tg.themeParams || {};
        const root = doc.documentElement.style;
        if (p.bg_color) root.setProperty('--tg-theme-bg-color', p.bg_color);
        if (p.text_color) root.setProperty('--tg-theme-text-color', p.text_color);
        if (p.hint_color) root.setProperty('--tg-theme-hint-color', p.hint_color);
        if (p.link_color) root.setProperty('--tg-theme-link-color', p.link_color);
        if (p.button_color) root.setProperty('--tg-theme-button-color', p.button_color);
        if (p.button_text_color) root.setProperty('--tg-theme-button-text-color', p.button_text_color);
        if (p.secondary_bg_color) root.setProperty('--tg-theme-secondary-bg-color', p.secondary_bg_color);
        
        // Event handlers
        tg.onEvent('themeChanged', () => location.reload());
        tg.onEvent('fullscreenFailed', (err) => console.warn('[Telegram] Fullscreen failed:', err));
        
        // Hide Telegram banner if shown
        const banner = doc.getElementById('telegram-banner');
        if (banner) banner.style.display = 'none';

        // Expose global helpers
        (win as any).requestAppFullscreen = function() {
          if (typeof tg.requestFullscreen === 'function') {
            try { tg.requestFullscreen(); return true; } catch (e) { console.warn(e); }
          }
          return false;
        };
        
        (win as any).exitAppFullscreen = function() {
          if (typeof tg.exitFullscreen === 'function') {
            try { tg.exitFullscreen(); return true; } catch (e) { console.warn(e); }
          }
          return false;
        };
        
        // Debug info (use getTelegramInfo() in console)
        (win as any).getTelegramInfo = function() {
          return !tg ? 'Not in Telegram' : {
            version: tg.version,
            platform: tg.platform,
            isExpanded: tg.isExpanded,
            isFullscreen: tg.isFullscreen,
            isVerticalSwipesEnabled: tg.isVerticalSwipesEnabled,
            viewportHeight: tg.viewportHeight
          };
        };

        // Basic haptics helper
        const haptics = tg.HapticFeedback;
        const triggerHaptic = (type = 'medium') => {
          try {
            if (!haptics) return;
            if (type === 'selection') haptics.selectionChanged();
            else if (type === 'success') haptics.notificationOccurred('success');
            else if (type === 'warning') haptics.notificationOccurred('warning');
            else if (type === 'error') haptics.notificationOccurred('error');
            else haptics.impactOccurred(type as any);
          } catch {}
        };
        (win as any).triggerAppHaptic = triggerHaptic;

        // Prevent closing by swipe/back button
        try {
          // Back button interception (Android)
          if (tg.BackButton) {
            tg.BackButton.show();
            tg.BackButton.onClick(() => {
              tg.showConfirm?.('Закрыть приложение?', (ok) => {
                if (ok) tg.close();
              });
            });
          }
        } catch {}
        
        return true;
      }

      // CTA links + haptics
      function setupCTALinks() {
        const isTelegram = !!tg;
        doc.querySelectorAll('a[data-cta]').forEach(link => {
          if (isTelegram) {
            link.addEventListener('mouseenter', () => { try { tg.HapticFeedback?.selectionChanged(); } catch {} });
          }
          link.addEventListener('click', function(e) {
            const href = this.getAttribute('href');
            if (!href) return;
            const urlWithUtm = withUTM(href);
            if (isTelegram) {
              e.preventDefault();
              tg.openLink(urlWithUtm);
              try { tg.HapticFeedback?.impactOccurred('medium'); } catch {}
            } else {
              this.target = '_blank';
              this.rel = 'noopener noreferrer';
              this.href = urlWithUtm;
            }
          });
        });

        // Fullscreen toggles: any element with [data-fullscreen]
        doc.querySelectorAll('[data-fullscreen]')?.forEach(btn => {
          btn.addEventListener('click', () => {
            let ok = false;
            if (tg) { try { ok = (win as any).requestAppFullscreen?.() || false; } catch {} }
            if (!ok) {
              // Desktop fallback via Fullscreen API (must be user gesture)
              const el = doc.documentElement as any;
              const req = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
              if (req) try { req.call(el); } catch {}
            }
          });
        });
      }

      function updateLinksOnLoad() {
        if (tg) return;
        const params = getStoredUTM();
        if (!Object.keys(params).length) return;
        doc.querySelectorAll('a[data-cta]').forEach(link => {
          const href = link.getAttribute('href');
          if (href && !href.includes('utm_')) link.setAttribute('href', withUTM(href));
        });
      }

      // Main initialization - fast and simple
      function init() {
        console.log('[Init] Running initialization...');
        initTelegramWebApp();
        setupCTALinks();
        updateLinksOnLoad();
        console.log('[Init] Initialization complete');
      }

      // ALWAYS use window.load to ensure everything is ready (like test page)
      win.addEventListener('load', () => {
        console.log('[Init] window.load event - starting init');
        init();
      });
    })();
  </script>
</head>
<body>
  <!-- Skip to main content link for accessibility -->
  <a href="#main-content" class="skip-to-main">
    Перейти к основному содержимому
  </a>
  
  <main id="main-content">
    <slot />
  </main>
  
  <!-- Telegram WebApp initialization script - MUST be at end of body -->
  <script is:inline>
    (function() {
      const win = window;
      const doc = document;
      
      // Wait for Telegram WebApp to be available
      function initTelegramApp() {
        if (!win.Telegram?.WebApp) {
          setTimeout(initTelegramApp, 50);
          return;
        }
        
        const tg = win.Telegram.WebApp;
        console.log('[TG] Initializing v' + tg.version + ' on ' + tg.platform);
        
        // Add class to body to enable Telegram-specific styles
        doc.body.classList.add('tg-webapp');
        
        // Initialize
        tg.ready();
        tg.expand();
        tg.enableClosingConfirmation();
        
        // Update CSS variables with Telegram viewport data
        if (tg.viewportHeight) {
          doc.documentElement.style.setProperty('--tg-viewport-height', tg.viewportHeight + 'px');
        }
        if (tg.viewportStableHeight) {
          doc.documentElement.style.setProperty('--tg-viewport-stable-height', tg.viewportStableHeight + 'px');
        }
        
        // Update safe area insets if available
        if (tg.safeAreaInset) {
          doc.documentElement.style.setProperty('--tg-safe-area-inset-top', tg.safeAreaInset.top + 'px');
          doc.documentElement.style.setProperty('--tg-safe-area-inset-bottom', tg.safeAreaInset.bottom + 'px');
          doc.documentElement.style.setProperty('--tg-safe-area-inset-left', tg.safeAreaInset.left + 'px');
          doc.documentElement.style.setProperty('--tg-safe-area-inset-right', tg.safeAreaInset.right + 'px');
        }
        
        // Listen for viewport changes
        tg.onEvent('viewportChanged', () => {
          if (tg.viewportHeight) {
            doc.documentElement.style.setProperty('--tg-viewport-height', tg.viewportHeight + 'px');
          }
          if (tg.viewportStableHeight) {
            doc.documentElement.style.setProperty('--tg-viewport-stable-height', tg.viewportStableHeight + 'px');
          }
        });
        
        // Bot API 7.7+: Disable vertical swipes
        if (typeof tg.disableVerticalSwipes === 'function') {
          tg.disableVerticalSwipes();
        }
        
        // Bot API 8.0+: Request fullscreen
        if (typeof tg.requestFullscreen === 'function') {
          try {
            tg.requestFullscreen();
          } catch (err) {
            console.warn('[TG] Fullscreen error:', err);
          }
        }
        
        // Setup haptics for interactive elements
        const haptics = tg.HapticFeedback;
        if (haptics) {
          // Light haptic on all clickable elements
          const clickableSelectors = [
            'button',
            'a[href]',
            'a[data-cta]',
            '[role="button"]',
            '.btn-capsule',
            '.proof-item',
            '.step-card'
          ].join(', ');
          
          doc.querySelectorAll(clickableSelectors).forEach(el => {
            el.addEventListener('touchstart', () => {
              try {
                haptics.impactOccurred('light');
              } catch (e) {}
            }, { passive: true });
          });
          
          // Medium haptic on CTA buttons (on click)
          doc.querySelectorAll('a[data-cta], .btn-capsule').forEach(el => {
            el.addEventListener('click', () => {
              try {
                haptics.impactOccurred('medium');
              } catch (e) {}
            });
          });
          
          // Expose global haptics helper
          win.triggerHaptic = (type = 'medium') => {
            try {
              if (type === 'selection') haptics.selectionChanged();
              else if (type === 'success') haptics.notificationOccurred('success');
              else if (type === 'warning') haptics.notificationOccurred('warning');
              else if (type === 'error') haptics.notificationOccurred('error');
              else haptics.impactOccurred(type);
            } catch (e) {}
          };
        }
        
        console.log('[TG] ✅ Ready');
        
        // Setup touch events for interactive elements (replace hover)
        doc.querySelectorAll('.reveal-up, .proof-item, .step-card, .cta-section').forEach(el => {
          el.addEventListener('touchstart', () => {
            el.classList.add('touch-active');
          }, { passive: true });
          
          el.addEventListener('touchend', () => {
            setTimeout(() => el.classList.remove('touch-active'), 150);
          }, { passive: true });
        });
      }
      
      // Start initialization
      initTelegramApp();
    })();
  </script>
  
  <!-- Touch interaction styles for Telegram -->
  <style>
    /* Touch feedback for all interactive elements (Telegram only) */
    body.tg-webapp .touch-active {
      transform: scale(0.97);
      opacity: 0.85;
      transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    /* Enhanced touch feedback for buttons (Telegram only) */
    body.tg-webapp button.touch-active,
    body.tg-webapp .btn-capsule.touch-active,
    body.tg-webapp a[data-cta].touch-active {
      transform: scale(0.95);
      opacity: 0.9;
    }
    
    /* Disable hover effects in Telegram (they don't work) */
    body.tg-webapp *:hover {
      transform: none !important;
    }
    
    body.tg-webapp .reveal-up:hover,
    body.tg-webapp .proof-item:hover,
    body.tg-webapp .step-card:hover,
    body.tg-webapp .btn-capsule:hover,
    body.tg-webapp button:hover,
    body.tg-webapp a:hover {
      transform: none !important;
      box-shadow: none !important;
    }
    
    /* Better touch targets for Telegram */
    body.tg-webapp button,
    body.tg-webapp a[href],
    body.tg-webapp .btn-capsule {
      min-height: 44px;
      min-width: 44px;
    }
  </style>
</body>
</html>

