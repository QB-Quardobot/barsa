---
import '../styles/global.css';
import { parseUTMFromURL } from '../lib/utm';
import LoadingScreen from '../components/LoadingScreen.astro';
import criticalCSS from '../styles/critical.css?raw';

interface Props {
  title: string;
  description?: string;
  image?: string;
}

const { title, description = 'Инновационный продукт для вашего бизнеса', image = '/og.jpg' } = Astro.props;
// Derive origin from Astro.site when provided, otherwise from current URL
const requestUrl = Astro.url.toString();
const origin = (Astro.site ? (Astro.site as URL).origin : new URL(requestUrl).origin);
const fullTitle = `${title} | Product`;

// Get UTM parameters from URL
const url = Astro.url.toString();
const utmParams = parseUTMFromURL(url);

// Analytics IDs (set via environment variables or public env)
const GA4_MEASUREMENT_ID = import.meta.env.PUBLIC_GA4_MEASUREMENT_ID || null;
const YM_COUNTER_ID = import.meta.env.PUBLIC_YM_COUNTER_ID || null;
---

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <!-- Primary Meta Tags -->
  <title>{fullTitle}</title>
  <meta name="title" content={fullTitle}>
  <meta name="description" content={description}>
  <meta name="author" content="Product Team">
  <meta name="robots" content="index, follow">
  <meta name="language" content="Russian">
  <link rel="canonical" href={Astro.url.href}>
  <link rel="alternate" hrefLang="ru" href={Astro.url.href}>
  
  <!-- Theme Color -->
  <meta name="theme-color" content="#0a0a0a">
  <meta name="msapplication-TileColor" content="#0a0a0a">
  <meta name="color-scheme" content="dark light">
  <meta name="referrer" content="no-referrer-when-downgrade">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content={Astro.url.href}>
  <meta property="og:title" content={fullTitle}>
  <meta property="og:description" content={description}>
  <meta property="og:image" content={new URL(image, Astro.site || origin).href}>
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:type" content="image/jpeg">
  <meta property="og:site_name" content="Product">
  <meta property="og:locale" content="ru_RU">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content={Astro.url.href}>
  <meta name="twitter:title" content={fullTitle}>
  <meta name="twitter:description" content={description}>
  <meta name="twitter:image" content={new URL(image, Astro.site || origin).href}>
  <meta name="twitter:image:alt" content={fullTitle}>
  
  <!-- Preload Fonts -->
  <link rel="preload" href="/fonts/inter-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-medium.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/fonts/inter-bold.woff2" as="font" type="font/woff2" crossorigin>
  
  <!-- Preload Critical Images (page-specific, will be overridden in pages) -->
  
  <!-- Critical CSS - Inline for fastest first paint (loads before global.css) -->
  <style set:html={criticalCSS} />
  
  <!-- TEMPORARY: Early console interception for BackButton debug (will be removed later) -->
  <!-- This MUST run before any other scripts to capture all logs -->
  <script is:inline>
    (function() {
      'use strict';
      
      // Create debug log storage BEFORE any scripts run
      window._backbuttonDebugLogs = window._backbuttonDebugLogs || [];
      
      // Intercept console methods IMMEDIATELY (before any other scripts)
      const originalConsoleLog = console.log;
      const originalConsoleWarn = console.warn;
      const originalConsoleError = console.error;
      
      function addDebugLog(message, type) {
        type = type || 'info';
        const timestamp = new Date().toLocaleTimeString('ru-RU', { 
          hour12: false, 
          hour: '2-digit', 
          minute: '2-digit', 
          second: '2-digit',
          fractionalSecondDigits: 3
        });
        
        window._backbuttonDebugLogs.push({
          timestamp: timestamp,
          message: String(message),
          type: type
        });
        
        // Limit logs
        if (window._backbuttonDebugLogs.length > 200) {
          window._backbuttonDebugLogs.shift();
        }
      }
      
      console.log = function(...args) {
        const message = args.map(function(a) { 
          return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); 
        }).join(' ');
        
        // Check for [TG-BackButton] prefix
        if (message.includes('[TG-BackButton]')) {
          addDebugLog(message, 'info');
        }
        
        originalConsoleLog.apply(console, args);
      };
      
      console.warn = function(...args) {
        const message = args.map(function(a) { 
          return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); 
        }).join(' ');
        
        if (message.includes('[TG-BackButton]')) {
          addDebugLog(message, 'warn');
        }
        
        originalConsoleWarn.apply(console, args);
      };
      
      console.error = function(...args) {
        const message = args.map(function(a) { 
          return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); 
        }).join(' ');
        
        if (message.includes('[TG-BackButton]')) {
          addDebugLog(message, 'error');
        }
        
        originalConsoleError.apply(console, args);
      };
      
      // Also intercept window.logger when it's created
      Object.defineProperty(window, 'logger', {
        set: function(value) {
          this._logger = value;
          if (value && typeof value.log === 'function') {
            const originalLog = value.log;
            const originalWarn = value.warn;
            const originalError = value.error;
            
            value.log = function(...args) {
              const message = args.map(function(a) { 
                return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); 
              }).join(' ');
              if (message.includes('[TG-BackButton]')) {
                addDebugLog(message, 'info');
              }
              originalLog.apply(value, args);
            };
            
            value.warn = function(...args) {
              const message = args.map(function(a) { 
                return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); 
              }).join(' ');
              if (message.includes('[TG-BackButton]')) {
                addDebugLog(message, 'warn');
              }
              originalWarn.apply(value, args);
            };
            
            value.error = function(...args) {
              const message = args.map(function(a) { 
                return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); 
              }).join(' ');
              if (message.includes('[TG-BackButton]')) {
                addDebugLog(message, 'error');
              }
              originalError.apply(value, args);
            };
          }
        },
        get: function() {
          return this._logger;
        }
      });
    })();
  </script>
  
  <!-- CRITICAL: Blocking script to hide content IMMEDIATELY if navigating -->
  <!-- This MUST run before any content renders to prevent flash -->
  <!-- This script has HIGHEST priority and runs before critical.css applies -->
  <script is:inline>
    (function() {
      // Check sessionStorage IMMEDIATELY (before DOM is ready)
      if (typeof sessionStorage !== 'undefined') {
        const shouldShowLoader = sessionStorage.getItem('showLoadingScreen') === 'true';
        if (shouldShowLoader) {
          // Inject critical styles IMMEDIATELY to hide content
          // CRITICAL: Use maximum specificity to override critical.css
          const style = document.createElement('style');
          style.id = 'navigation-loading-critical';
          style.textContent = `
            /* Maximum specificity to override critical.css */
            html body #main-content {
              visibility: hidden !important;
              opacity: 0 !important;
            }
            html body #loading-screen.loading-screen,
            html body div#loading-screen.loading-screen {
              display: flex !important;
              visibility: visible !important;
              opacity: 1 !important;
              z-index: 99999 !important;
              pointer-events: auto !important;
            }
          `;
          // Insert at the very beginning of head to ensure highest priority
          if (document.head) {
            document.head.insertBefore(style, document.head.firstChild);
          } else {
            // If head doesn't exist yet, wait for it
            const observer = new MutationObserver(function(mutations, obs) {
              if (document.head) {
                document.head.insertBefore(style, document.head.firstChild);
                obs.disconnect();
              }
            });
            observer.observe(document.documentElement, { childList: true, subtree: true });
            // Fallback: try again after a short delay
            setTimeout(function() {
              if (document.head && !document.getElementById('navigation-loading-critical')) {
                document.head.insertBefore(style, document.head.firstChild);
              }
            }, 0);
          }
        }
      }
    })();
  </script>
  
  <!-- Polyfill for async CSS loading -->
  <script is:inline>
    /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
    (function(w){"use strict";var loadCSS=function(href,before,media){var doc=w.document;var ss=doc.createElement("link");var ref;if(before){ref=before}else{var refs=(doc.body||doc.getElementsByTagName("head")[0]).childNodes;ref=refs[refs.length-1]}var sheets=doc.styleSheets;ss.rel="stylesheet";ss.href=href;ss.media="print";ss.onload=function(){ss.media=media||"all";ss.onload=null};ref.parentNode.insertBefore(ss,ref.nextSibling);return ss};if(typeof exports!=="undefined"){exports.loadCSS=loadCSS}else{w.loadCSS=loadCSS}}(typeof global!=="undefined"?global:this));
  </script>
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="manifest" href="/manifest.webmanifest">
  
  <!-- Service Worker Registration -->
  <script is:inline>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('/sw.js')
          .then(function(registration) {
            console.log('[SW] Registered:', registration.scope);
          })
          .catch(function(error) {
            console.error('[SW] Registration failed:', error);
          });
      });
    }
  </script>
  
  <!-- Performance Hints -->
  <link rel="preconnect" href="https://telegram.org" crossorigin>
  <link rel="dns-prefetch" href="//telegram.org">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://www.googletagmanager.com" crossorigin>
  <link rel="preconnect" href="https://mc.yandex.ru" crossorigin>
  <!-- Swiper CDN optimization -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  
  {/* Analytics configuration - IDs passed to client script */}
  {GA4_MEASUREMENT_ID && (
    <script type="text/plain" data-ga4-id={GA4_MEASUREMENT_ID}></script>
  )}
  {YM_COUNTER_ID && (
    <script type="text/plain" data-ym-id={YM_COUNTER_ID}></script>
  )}
  
  <!-- Telegram Mini App Safe Area Support -->
  <style>
    :root {
      /* Safe area insets from Telegram WebApp */
      --tg-safe-area-inset-top: env(safe-area-inset-top, 0px);
      --tg-safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
      --tg-safe-area-inset-left: env(safe-area-inset-left, 0px);
      --tg-safe-area-inset-right: env(safe-area-inset-right, 0px);
      
      /* Viewport height that accounts for safe areas */
      --tg-viewport-height: 100vh;
      --tg-viewport-stable-height: 100vh;
    }
    
    /* Telegram WebApp specific styles */
    body.tg-webapp {
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
      position: fixed;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      /* Disable text selection for native app feel */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      /* Disable long-press context menu */
      -webkit-touch-callout: none;
    }
    
    /* Main content scrollable area (only in Telegram) */
    body.tg-webapp #main-content {
      width: 100%;
      height: 100vh;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding-top: var(--tg-safe-area-inset-top);
      padding-bottom: var(--tg-safe-area-inset-bottom);
      padding-left: var(--tg-safe-area-inset-left);
      padding-right: var(--tg-safe-area-inset-right);
      /* Ensure content is visible */
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      z-index: 1 !important;
    }
    
    /* Safe area padding for non-Telegram */
    body:not(.tg-webapp) #main-content {
      padding-top: var(--tg-safe-area-inset-top);
      padding-bottom: var(--tg-safe-area-inset-bottom);
      padding-left: var(--tg-safe-area-inset-left);
      padding-right: var(--tg-safe-area-inset-right);
      /* Ensure content is visible */
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    
    /* Ensure buttons respect safe areas */
    .btn-capsule,
    button,
    a[data-cta] {
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
  </style>
  
  <!-- Telegram WebApp API - loads synchronously BEFORE inline scripts -->
  <script is:inline src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <!-- JSON-LD Schema -->
  <script type="application/ld+json" set:html={JSON.stringify({
    '@context': 'https://schema.org',
    '@type': 'WebSite',
    name: 'AI Model 2.0',
    url: Astro.url.href,
    inLanguage: 'ru-RU',
    potentialAction: {
      '@type': 'SearchAction',
      target: `${Astro.url.origin}/?q={search_term_string}`,
      'query-input': 'required name=search_term_string'
    },
    publisher: {
      '@type': 'Organization',
      name: 'AI Model 2.0',
      url: Astro.url.origin
    }
  })}></script>
  
  <!-- Pass UTM params to client -->
  <script define:vars={{ utmParams: JSON.stringify(utmParams) }}>
    window.utmParams = utmParams;
  </script>
  
  <!-- Initialize UTM, Telegram WebApp and CTA links (consolidated) -->
  <script is:inline>
    (function() {
      const win = window;
      const doc = document;
      let tg = null; // Telegram WebApp instance
      
      // Production-safe logger
      const isDev = win.location.hostname === 'localhost' || win.location.hostname === '127.0.0.1' || win.location.hostname.includes('.ngrok.io') || win.location.hostname.includes('.trycloudflare.com');
      const logger = {
        log: function(...args) { if (isDev) console.log(...args); },
        warn: function(...args) { if (isDev) console.warn(...args); },
        error: function(...args) { console.error(...args); }
      };
      
      // Cleanup registry
      const cleanupFunctions = [];
      function registerCleanup(fn) {
        cleanupFunctions.push(fn);
        return function() {
          const index = cleanupFunctions.indexOf(fn);
          if (index > -1) cleanupFunctions.splice(index, 1);
        };
      }
      
      // Cleanup on unload
      const unloadCleanup = function() {
        cleanupFunctions.forEach(function(fn) { try { fn(); } catch (e) {} });
        cleanupFunctions.length = 0;
      };
      win.addEventListener('beforeunload', unloadCleanup);
      
      // UTM helpers
      const storedUtmKey = 'utm_params';
      const utm = (win.utmParams && typeof win.utmParams === 'object') ? win.utmParams : {};
      if (Object.keys(utm).length) {
        try { sessionStorage.setItem(storedUtmKey, JSON.stringify(utm)); } catch {}
      }

      function getStoredUTM() {
        try { return JSON.parse(sessionStorage.getItem(storedUtmKey) || '{}'); } catch { return {}; }
      }
      function withUTM(url) {
        const params = getStoredUTM();
        if (!Object.keys(params).length) return url;
        try {
          const u = new URL(url);
          Object.entries(params).forEach(([k, v]) => { if (v && !u.searchParams.has(k)) u.searchParams.set(k, v); });
          return u.toString();
        } catch {
          const qs = new URLSearchParams(params).toString();
          return url + (url.includes('?') ? '&' : '?') + qs;
        }
      }

      // Initialize Telegram WebApp
      function initTelegramWebApp() {
        try {
          logger.log('[TG-Init] Function called');
        tg = win.Telegram?.WebApp;
        if (!tg) {
            logger.log('[TG-Init] WebApp not available - running in browser');
          return false;
        }
        
          logger.log('[TG-Init] Found WebApp v' + tg.version + ' on ' + tg.platform);
          logger.log('[TG-Init] Current state: isExpanded=' + tg.isExpanded + ', isFullscreen=' + tg.isFullscreen);
          
          // Initialize app
          logger.log('[TG-Init] Calling ready()...');
          tg.ready();
          
          logger.log('[TG-Init] Calling expand()...');
          tg.expand();
          
          logger.log('[TG-Init] Calling enableClosingConfirmation()...');
          tg.enableClosingConfirmation();
          
          // Bot API 7.7+: Disable vertical swipes to prevent accidental closing
          if (typeof tg.disableVerticalSwipes === 'function') {
            logger.log('[TG-Init] Calling disableVerticalSwipes()...');
            try {
              tg.disableVerticalSwipes();
              logger.log('[TG-Init] After disableVerticalSwipes: isVerticalSwipesEnabled=' + tg.isVerticalSwipesEnabled);
            } catch (err) {
              logger.warn('[TG-Init] disableVerticalSwipes error:', err);
            }
          } else {
            logger.warn('[TG-Init] disableVerticalSwipes not available');
          }
          
          // Bot API 8.0+: Request fullscreen mode
          if (typeof tg.requestFullscreen === 'function') {
            logger.log('[TG-Init] Calling requestFullscreen()...');
            try {
              tg.requestFullscreen();
              logger.log('[TG-Init] After requestFullscreen: isFullscreen=' + tg.isFullscreen);
            } catch (err) {
              logger.warn('[TG-Init] Fullscreen error:', err);
            }
          } else {
            logger.warn('[TG-Init] requestFullscreen not available');
          }
        } catch (error) {
          logger.error('[TG-Init] Error:', error);
        }
        
        // Apply theme
        const p = tg.themeParams || {};
        const root = doc.documentElement.style;
        if (p.bg_color) root.setProperty('--tg-theme-bg-color', p.bg_color);
        if (p.text_color) root.setProperty('--tg-theme-text-color', p.text_color);
        if (p.hint_color) root.setProperty('--tg-theme-hint-color', p.hint_color);
        if (p.link_color) root.setProperty('--tg-theme-link-color', p.link_color);
        if (p.button_color) root.setProperty('--tg-theme-button-color', p.button_color);
        if (p.button_text_color) root.setProperty('--tg-theme-button-text-color', p.button_text_color);
        if (p.secondary_bg_color) root.setProperty('--tg-theme-secondary-bg-color', p.secondary_bg_color);
        
        // Event handlers
        tg.onEvent('themeChanged', () => location.reload());
        tg.onEvent('fullscreenFailed', function(err) { logger.warn('[Telegram] Fullscreen failed:', err); });
        
        // Hide Telegram banner if shown
        const banner = doc.getElementById('telegram-banner');
        if (banner) banner.style.display = 'none';

        // Expose global helpers
        win.requestAppFullscreen = function() {
          if (typeof tg.requestFullscreen === 'function') {
            try { tg.requestFullscreen(); return true; } catch (e) { logger.warn(e); }
          }
          return false;
        };
        
        win.exitAppFullscreen = function() {
          if (typeof tg.exitFullscreen === 'function') {
            try { tg.exitFullscreen(); return true; } catch (e) { logger.warn(e); }
          }
          return false;
        };
        
        // Debug info (use getTelegramInfo() in console)
        win.getTelegramInfo = function() {
          return !tg ? 'Not in Telegram' : {
            version: tg.version,
            platform: tg.platform,
            isExpanded: tg.isExpanded,
            isFullscreen: tg.isFullscreen,
            isVerticalSwipesEnabled: tg.isVerticalSwipesEnabled,
            viewportHeight: tg.viewportHeight
          };
        };

        // Basic haptics helper
        const haptics = tg.HapticFeedback;
        const triggerHaptic = (type = 'medium') => {
          try {
            if (!haptics) return;
            if (type === 'selection') haptics.selectionChanged();
            else if (type === 'success') haptics.notificationOccurred('success');
            else if (type === 'warning') haptics.notificationOccurred('warning');
            else if (type === 'error') haptics.notificationOccurred('error');
            else haptics.impactOccurred(type);
          } catch {}
        };
        win.triggerAppHaptic = triggerHaptic;

        // Back button navigation handler
        // FIX #5: Add delay (50-100ms) after tg.expand() before registering BackButton
        // According to internet sources, SDK needs time to fully initialize after expand()
        // This ensures BackButton API is ready to accept handlers
        
        // CRITICAL DEBUG: Log that we're attempting to setup BackButton
        logger.log('[TG-BackButton] Attempting to setup BackButton after tg.expand()');
        logger.log('[TG-BackButton] Debug info:', {
          tgAvailable: !!tg,
          backButtonAvailable: !!tg.BackButton,
          isReady: tg.isReady,
          isExpanded: tg.isExpanded,
          version: tg.version,
          platform: tg.platform
        });
        
        setTimeout(() => {
          try {
            // FIX #4: Check tg.isReady before registering BackButton handler
            // According to internet sources, SDK must be fully ready before BackButton registration
            logger.log('[TG-BackButton] Checking SDK state after delay...');
            
            if (tg.isReady === false) {
              logger.warn('[TG-BackButton] SDK isReady is false, waiting another 100ms...');
              setTimeout(() => {
                if (tg && tg.isReady !== false && tg.BackButton) {
                  logger.log('[TG-BackButton] SDK now ready, setting up BackButton...');
                  setupBackButton();
                } else {
                  logger.error('[TG-BackButton] SDK still not ready after delay');
                  logger.error('[TG-BackButton] Final state:', {
                    tgAvailable: !!tg,
                    backButtonAvailable: !!tg.BackButton,
                    isReady: tg ? tg.isReady : 'N/A'
                  });
                }
              }, 100);
              return;
            }
            
            if (tg.BackButton) {
              logger.log('[TG-BackButton] BackButton available, calling setupBackButton()...');
              setupBackButton();
            } else {
              logger.warn('[TG-BackButton] BackButton not available');
              logger.warn('[TG-BackButton] tg object:', {
                hasBackButton: 'BackButton' in tg,
                tgKeys: Object.keys(tg).slice(0, 10)
              });
            }
          } catch (e) {
            logger.error('[TG-BackButton] Error in setTimeout:', e);
            logger.error('[TG-BackButton] Error stack:', e.stack);
          }
        }, 100); // 100ms delay after tg.expand() as recommended by internet sources
        
        // BackButton setup function (extracted for reuse)
        function setupBackButton() {
          logger.log('[TG-BackButton] setupBackButton() called');
          
          if (!tg || !tg.BackButton) {
            logger.warn('[TG-BackButton] Cannot setup: tg or BackButton not available');
            logger.warn('[TG-BackButton] tg:', !!tg, 'BackButton:', !!tg ? !!tg.BackButton : 'N/A');
            return;
          }
          
          logger.log('[TG-BackButton] Starting BackButton setup...');
          
          try {
            let backButtonVisible = false;
            
            function isPhotoModalOpen() {
              return typeof win.isPhotoModalOpen === 'function' ? win.isPhotoModalOpen() : false;
            }
            
            function closePhotoModal() {
              if (typeof win.closePhotoModal === 'function') {
                win.closePhotoModal();
                return true;
              }
              return false;
            }
            
            function isCurrencyModalOpen() {
              return typeof win.isCurrencyModalOpen === 'function' ? win.isCurrencyModalOpen() : false;
            }
            
            function closeCurrencyModal() {
              if (typeof win.closeCurrencyModal === 'function') {
                win.closeCurrencyModal();
                return true;
              }
              return false;
            }
            
            // Check if we're on the first page (index/home page)
            function isFirstPage() {
              const pathname = win.location.pathname;
              return pathname === '/' || pathname === '/index.html' || pathname.endsWith('/index');
            }
            
            // Function to check if we can go back
            function canGoBack() {
              // Always show back button - it handles all navigation cases
              // 1. Close modals if open
              // 2. Go back if on second page
              // 3. Scroll to top if scrolled on first page
              // 4. Show close confirmation if at top of first page
              return true;
            }
            
            // Function to handle back action
            function handleBackClick() {
              // FIX #6: Add detailed logging for debugging
              logger.log('[TG-BackButton] handleBackClick() called');
              logger.log('[TG-BackButton] Current state:', {
                pathname: win.location.pathname,
                isFirstPage: isFirstPage(),
                historyLength: win.history.length,
                currencyModalOpen: isCurrencyModalOpen(),
                photoModalOpen: isPhotoModalOpen()
              });
              
              // First priority: close currency modal if open
              if (isCurrencyModalOpen()) {
                logger.log('[TG-BackButton] Closing currency modal');
                closeCurrencyModal();
                triggerHaptic('light');
                return;
              }
              
              // Second priority: close photo modal if open
              if (isPhotoModalOpen()) {
                logger.log('[TG-BackButton] Closing photo modal');
                closePhotoModal();
                triggerHaptic('light');
                return;
              }
              
              // Third priority: if on second page, go back to first page
              if (!isFirstPage()) {
                logger.log('[TG-BackButton] Not on first page, attempting navigation back');
                try {
                  // FIX #2: Clear sessionStorage ASYNCHRONOUSLY to avoid blocking history.back()
                  // According to internet sources, synchronous sessionStorage operations
                  // can interfere with navigation. Use setTimeout(0) to make it async.
                  if (typeof sessionStorage !== 'undefined') {
                    setTimeout(() => {
                      sessionStorage.removeItem('showLoadingScreen');
                      logger.log('[TG-BackButton] sessionStorage cleared (async)');
                    }, 0);
                  }
                  
                  logger.log('[TG-BackButton] Calling history.back()...');
                  win.history.back();
                  triggerHaptic('light');
                  logger.log('[TG-BackButton] history.back() called successfully');
                  return;
                } catch (e) {
                  logger.error('[TG-BackButton] Error with history.back():', e);
                  // Fallback: navigate to home
                  if (typeof sessionStorage !== 'undefined') {
                    sessionStorage.removeItem('showLoadingScreen');
                  }
                  logger.log('[TG-BackButton] Fallback: navigating to home');
                  win.location.href = '/';
                  return;
                }
              }
              
              // Third priority: on first page, scroll to top if scrolled
              logger.log('[TG-BackButton] On first page, checking scroll position');
              const mainContent = doc.getElementById('main-content');
              const scrollable = mainContent || doc.documentElement;
              const scrollTop = scrollable.scrollTop || 0;
              
              if (scrollTop > 100) {
                logger.log('[TG-BackButton] Scrolling to top (scrollTop:', scrollTop, ')');
                scrollable.scrollTo({
                  top: 0,
                  behavior: 'smooth'
                });
                triggerHaptic('light');
                return;
              }
              
              // Last resort: on first page at top, show close confirmation
              logger.log('[TG-BackButton] At top of first page, showing close confirmation');
              triggerHaptic('medium');
              tg.showConfirm?.('Закрыть приложение?', (ok) => {
                if (ok) {
                  logger.log('[TG-BackButton] User confirmed app close');
                  triggerHaptic('heavy');
                  tg.close();
                } else {
                  logger.log('[TG-BackButton] User cancelled app close');
                }
              });
            }
            
            // Function to update back button visibility
            function updateBackButton() {
              const shouldShow = canGoBack();
              
              try {
                if (shouldShow && !backButtonVisible) {
                  tg.BackButton.show();
                  backButtonVisible = true;
                  logger.log('[TG-BackButton] Button shown');
                } else if (!shouldShow && backButtonVisible) {
                  tg.BackButton.hide();
                  backButtonVisible = false;
                  logger.log('[TG-BackButton] Button hidden');
                }
              } catch (error) {
                logger.error('[TG-BackButton] Error updating visibility:', error);
              }
            }
            
            // Set up back button click handler
            // FIX #3: Call BackButton.show() BEFORE registering onClick handler
            // According to internet sources and Telegram documentation, show() should be called first
            // This ensures button is visible and ready to receive events
            try {
              if (canGoBack()) {
                tg.BackButton.show();
                backButtonVisible = true;
                logger.log('[TG-BackButton] Button shown before handler registration');
              }
            } catch (e) {
              logger.error('[TG-BackButton] Error showing button:', e);
            }
            
            // FIX #1: Register onClick handler AFTER showing button
            // According to internet sources, this is the correct order
            tg.BackButton.onClick(handleBackClick);
            logger.log('[TG-BackButton] onClick handler registered');
            
            // CRITICAL: Update button visibility immediately (not just after delay)
            // This ensures button is shown right after handler registration
            updateBackButton();
            
            // Monitor scroll position to show/hide button
            const scrollable = doc.getElementById('main-content') || doc.documentElement;
            let scrollTimeout;
            
            scrollable.addEventListener('scroll', () => {
              clearTimeout(scrollTimeout);
              scrollTimeout = setTimeout(updateBackButton, 100);
            }, { passive: true });
            
            // Monitor popstate for history changes
            win.addEventListener('popstate', () => {
              setTimeout(updateBackButton, 100);
            });
            
            // Monitor location changes (for navigation between pages)
            let currentPath = win.location.pathname;
            const checkPathChange = () => {
              const newPath = win.location.pathname;
              if (newPath !== currentPath) {
                currentPath = newPath;
                updateBackButton();
              }
            };
            
            // Check path changes periodically (for SPA-like navigation)
            setInterval(checkPathChange, 500);
            
            // Initial check
            setTimeout(updateBackButton, 500);
            
            // Update on viewport changes
            win.addEventListener('resize', () => {
              setTimeout(updateBackButton, 100);
            });
            
            // FIX #6: Add detailed logging for debugging
            logger.log('[TG-BackButton] Setup complete:', {
              isReady: tg.isReady,
              isExpanded: tg.isExpanded,
              backButtonAvailable: !!tg.BackButton,
              backButtonVisible: backButtonVisible,
              currentPath: win.location.pathname,
              historyLength: win.history.length
            });
          } catch (e) {
            logger.error('[TG-BackButton] Error in setupBackButton:', e);
            logger.error('[TG-BackButton] Error details:', e.message, e.stack);
          }
        }
        
        return true;
      }

      // Track click with Google Analytics 4 & Яндекс.Метрика
      function trackClick(href, buttonText) {
        try {
          // Get UTM params from sessionStorage
          const utmParams = getStoredUTM();
          
          // Google Analytics 4: Track CTA click event
          if (typeof gtag !== 'undefined' && gtag) {
            gtag('event', 'cta_click', {
              event_category: 'CTA',
              event_label: buttonText || '',
              link_url: href,
              ...(utmParams.utm_source && { utm_source: utmParams.utm_source }),
              ...(utmParams.utm_medium && { utm_medium: utmParams.utm_medium }),
              ...(utmParams.utm_campaign && { utm_campaign: utmParams.utm_campaign }),
              ...(utmParams.utm_term && { utm_term: utmParams.utm_term }),
              ...(utmParams.utm_content && { utm_content: utmParams.utm_content }),
            });
          }
          
          // Яндекс.Метрика: Track goal (cta_click)
          if (typeof ym !== 'undefined' && ym && window.ym) {
            // Get counter ID from ym function (first initialized counter)
            if (window.ym.a && window.ym.a.length > 0 && window.ym.a[0][0]) {
              const ymId = window.ym.a[0][0];
              try {
                window.ym(ymId, 'reachGoal', 'cta_click', {
                  label: buttonText || '',
                  href: href,
                });
              } catch (e) {}
            }
          }
        } catch (e) {
          // Silent fail for analytics
        }
      }
      
      // Initialize session ID for analytics (if not exists)
      if (typeof sessionStorage !== 'undefined' && !sessionStorage.getItem('analytics_session_id')) {
        sessionStorage.setItem('analytics_session_id', 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
      }
      
      // CTA links + haptics + proper Telegram link handling
      function setupCTALinks() {
        const isTelegram = !!tg;
        const haptics = isTelegram ? tg.HapticFeedback : null;
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        doc.querySelectorAll('a[data-cta]').forEach(link => {
          const href = link.getAttribute('href') || '';
          const buttonText = link.textContent.trim();
          const isTelegramLink = href.includes('t.me/') || href.startsWith('https://t.me/');
          
          // Haptic feedback for touch devices (Telegram only)
          if (isTelegram && haptics && isTouchDevice) {
            // Light haptic on touch start
            link.addEventListener('touchstart', function() {
              try {
                haptics.impactOccurred('light');
              } catch (e) {}
            }, { passive: true, once: false });
            
            // Selection haptic on hover (desktop Telegram or pointer devices)
            link.addEventListener('pointerenter', function() {
              try {
                haptics.selectionChanged();
              } catch (e) {}
            }, { passive: true });
          }
          
          link.addEventListener('click', function(e) {
            if (!href) return;
            
            const urlWithUtm = withUTM(href);
            
            // Check if internal link
            const isInternalLink = href.startsWith('/') || href.startsWith(window.location.origin) || (!href.includes('://') && !href.includes('t.me/'));
            
            // Track click
            trackClick(urlWithUtm, buttonText);
            
            // Medium haptic on click (Telegram only)
            if (isTelegram && haptics) {
              try {
                haptics.impactOccurred('medium');
              } catch (e) {}
            }
            
            if (isTelegram) {
              if (isInternalLink) {
                // Internal link in Telegram - show loading screen before navigation
                const loadingScreen = doc.getElementById('loading-screen');
                if (loadingScreen) {
                  // Mark that next page should show loader
                  sessionStorage.setItem('showLoadingScreen', 'true');
                  // Show loader immediately
                  loadingScreen.style.display = 'flex';
                  loadingScreen.style.visibility = 'visible';
                  loadingScreen.style.pointerEvents = 'auto';
                  loadingScreen.style.opacity = '1';
                  // Hide main content
                  const mainContent = doc.getElementById('main-content');
                  if (mainContent) {
                    mainContent.style.visibility = 'hidden';
                    mainContent.style.opacity = '0';
                  }
                }
                // CRITICAL FIX: Allow normal navigation (stay in WebApp)
                // DO NOT use location.href - it doesn't create proper history
                // Instead, update href and let browser handle navigation naturally
                this.href = urlWithUtm;
                
                // Log navigation for debugging
                logger.log('[Navigation] CTA link clicked:', {
                  href: urlWithUtm,
                  willCreateHistory: true,
                  currentHistoryLength: win.history.length,
                  currentPath: win.location.pathname
                });
                
                // Don't prevent default - let browser handle internal navigation
                // This ensures history.back() will work correctly
                return;
              } else {
                // External link in Telegram
                e.preventDefault();
                
                // For Telegram links, use openTelegramLink (stays in app)
                // For other external links, use openLink (opens in browser)
                if (isTelegramLink && typeof tg.openTelegramLink === 'function') {
                  try {
                    tg.openTelegramLink(urlWithUtm);
                  } catch (err) {
                    // Fallback to openLink if openTelegramLink fails
                    try { tg.openLink(urlWithUtm); } catch {}
                  }
                } else {
                  // External link - open in browser
                  try {
                    tg.openLink(urlWithUtm);
                  } catch {}
                }
              }
            } else {
              // Not in Telegram
              if (isInternalLink) {
                // Internal link - show loading screen before navigation (if enabled)
                const loadingScreen = doc.getElementById('loading-screen');
                const showInBrowser = loadingScreen && loadingScreen.getAttribute('data-show-in-browser') === 'true';
                if (showInBrowser && loadingScreen) {
                  // Mark that next page should show loader
                  sessionStorage.setItem('showLoadingScreen', 'true');
                  // Show loader immediately
                  loadingScreen.style.display = 'flex';
                  loadingScreen.style.visibility = 'visible';
                  loadingScreen.style.pointerEvents = 'auto';
                  loadingScreen.style.opacity = '1';
                  // Hide main content
                  const mainContent = doc.getElementById('main-content');
                  if (mainContent) {
                    mainContent.style.visibility = 'hidden';
                    mainContent.style.opacity = '0';
                  }
                }
                // CRITICAL FIX: Open in same tab (normal navigation)
                // DO NOT use location.href - it doesn't create proper history
                // Instead, update href and let browser handle navigation naturally
                this.href = urlWithUtm;
                this.target = '_self';
                
                // Log navigation for debugging
                logger.log('[Navigation] Internal link clicked (browser):', {
                  href: urlWithUtm,
                  willCreateHistory: true,
                  currentHistoryLength: win.history.length,
                  currentPath: win.location.pathname
                });
                
                // Don't prevent default - let browser handle navigation normally
                // This ensures history.back() will work correctly
              } else {
                // External link - open in new tab
                e.preventDefault();
                this.target = '_blank';
                this.rel = 'noopener noreferrer';
                this.href = urlWithUtm;
                // For external links, manually open to ensure new tab
                window.open(urlWithUtm, '_blank', 'noopener,noreferrer');
              }
            }
          });
        });

        // Fullscreen toggles: any element with [data-fullscreen]
        doc.querySelectorAll('[data-fullscreen]')?.forEach(btn => {
          btn.addEventListener('click', () => {
            let ok = false;
            if (tg) { try { ok = (win.requestAppFullscreen && win.requestAppFullscreen()) || false; } catch {} }
            if (!ok) {
              // Desktop fallback via Fullscreen API (must be user gesture)
              const el = doc.documentElement;
              const req = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
              if (req) try { req.call(el); } catch {}
            }
          });
        });
      }
      
      // Global handler for ALL internal links (not just data-cta)
      // This ensures loading screen shows for any internal navigation
      // CRITICAL: Must NOT interfere with back button navigation
      function setupGlobalInternalLinks() {
        const isTelegram = !!tg;
        
        // Use event delegation on document for all internal links
        // CRITICAL: Use capture phase to run before other handlers, but don't interfere with BackButton
        doc.addEventListener('click', function(e) {
          // CRITICAL FIX: Don't interfere with BackButton clicks
          // BackButton clicks don't trigger document click events, but we check anyway
          const target = e.target as HTMLElement;
          const link = target.closest('a[href]') as HTMLAnchorElement;
          if (!link) return;
          
          // Skip if already handled by setupCTALinks (data-cta links)
          if (link.hasAttribute('data-cta')) return;
          
          // CRITICAL: Skip if this is a back button or history navigation
          // Check if link is a back button or has special navigation attribute
          if (link.hasAttribute('data-back') || link.hasAttribute('data-history-back')) {
            return; // Let back button handler process this
          }
          
          // CRITICAL FIX: Don't prevent default on internal links - let browser create history
          // This ensures history.back() will work correctly
          
          const href = link.getAttribute('href') || '';
          
          // CRITICAL: Skip if href is empty or just '#' (anchor links)
          // These should be handled by smooth scroll, not navigation
          if (!href || href === '#' || href.startsWith('#')) {
            return;
          }
          
          // Check if internal link
          const isInternalLink = href.startsWith('/') || 
                                 href.startsWith(window.location.origin) || 
                                 (!href.includes('://') && !href.includes('t.me/'));
          
          if (!isInternalLink) return;
          
          // Show loading screen before navigation
          const loadingScreen = doc.getElementById('loading-screen');
          if (loadingScreen) {
            // Mark that next page should show loader
            sessionStorage.setItem('showLoadingScreen', 'true');
            // Show loader immediately
            loadingScreen.style.display = 'flex';
            loadingScreen.style.visibility = 'visible';
            loadingScreen.style.pointerEvents = 'auto';
            loadingScreen.style.opacity = '1';
            // Hide main content
            const mainContent = doc.getElementById('main-content');
            if (mainContent) {
              mainContent.style.visibility = 'hidden';
              mainContent.style.opacity = '0';
            }
          }
          
          // CRITICAL FIX: Don't prevent default on internal links - let browser handle navigation normally
          // This ensures browser history is created correctly for history.back() to work
          // 
          // IMPORTANT: We show loading screen but DO NOT call e.preventDefault()
          // This allows the browser to:
          // 1. Create proper history entry
          // 2. Navigate normally using <a href> behavior
          // 3. Allow history.back() to work correctly
          //
          // If we used location.href or prevented default, history would NOT be created properly
          
          // Log navigation for debugging
          logger.log('[Navigation] Internal link clicked:', {
            href: href,
            willCreateHistory: true,
            currentHistoryLength: win.history.length,
            currentPath: win.location.pathname
          });
          
          // Use capture phase to run before other handlers, but don't interfere with navigation
        }, true); // Use capture phase to run before other handlers
      }
      
      setupGlobalInternalLinks();

      function updateLinksOnLoad() {
        if (tg) return;
        const params = getStoredUTM();
        if (!Object.keys(params).length) return;
        doc.querySelectorAll('a[data-cta]').forEach(link => {
          const href = link.getAttribute('href');
          if (href && !href.includes('utm_')) link.setAttribute('href', withUTM(href));
        });
      }

      // Initialize Google Analytics 4 & Яндекс.Метрика
      function initAnalytics() {
        // Get IDs from script tag (injected by Astro)
        const ga4IdEl = doc.querySelector('script[data-ga4-id]');
        const ymIdEl = doc.querySelector('script[data-ym-id]');
        const ga4Id = ga4IdEl ? ga4IdEl.getAttribute('data-ga4-id') : null;
        const ymId = ymIdEl ? ymIdEl.getAttribute('data-ym-id') : null;
        
        // Google Analytics 4
        if (ga4Id && typeof window !== 'undefined') {
          try {
            // Load gtag.js
            const script = document.createElement('script');
            script.async = true;
            script.src = 'https://www.googletagmanager.com/gtag/js?id=' + ga4Id;
            document.head.appendChild(script);
            
            // Initialize dataLayer
            window.dataLayer = window.dataLayer || [];
            window.gtag = function() {
              if (window.dataLayer) {
                window.dataLayer.push(arguments);
              }
            };
            
            window.gtag('js', new Date());
            window.gtag('config', ga4Id, {
              send_page_view: true,
              page_location: window.location.href,
              page_title: document.title,
            });
            
            // Track initial page view with UTM (GA4 automatically captures UTM from URL)
            setTimeout(() => {
              const utmParams = getStoredUTM();
              const urlParams = new URLSearchParams(window.location.search);
              
              // UTM уже передаются автоматически через page_location, но можно явно указать
              if (window.gtag) {
                window.gtag('event', 'page_view', {
                  page_path: window.location.pathname + window.location.search,
                  page_title: document.title,
                });
              }
            }, 100);
          } catch (e) {
            logger.warn('[Analytics] GA4 init failed:', e);
          }
        }
        
        // Яндекс.Метрика
        if (ymId && typeof window !== 'undefined') {
          try {
            const counterId = Number(ymId);
            
            // Create ym function
            (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
            m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
            (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
            
            // Initialize counter
            if (window.ym) {
              window.ym(counterId, "init", {
                clickmap: true,
                trackLinks: true,
                accurateTrackBounce: true,
                webvisor: true
              });
            }
            
            // Create noscript fallback
            const noscript = document.createElement('noscript');
            noscript.innerHTML = '<div><img src="https://mc.yandex.ru/watch/' + counterId + '" style="position:absolute; left:-9999px;" alt="" /></div>';
            document.body.appendChild(noscript);
          } catch (e) {
            logger.warn('[Analytics] Yandex Metrika init failed:', e);
          }
        }
      }

      // Initialize error handling (must be first)
      if (typeof window !== 'undefined') {
        try {
          // Global error handler
          window.onerror = function(message, source, lineno, colno, error) {
            logger.error('[Global Error]', message, error || { source, lineno, colno });
            return false; // Allow default handling
          };
          
          // Unhandled promise rejections
          window.addEventListener('unhandledrejection', function(event) {
            logger.error('[Unhandled Promise]', event.reason);
          });
        } catch (e) {
          logger.error('[Init] Error handler setup failed:', e);
        }
      }
      
      // Initialize performance monitoring (async, non-blocking)
      // Disabled in production builds to avoid module loading issues
      // Performance monitoring can be enabled via separate script if needed
      // NOTE: Dynamic import() is not available in inline scripts, disabled for now
      
      // Main initialization - fast and simple
      function init() {
        try {
          logger.log('[Init] Running initialization...');
          initTelegramWebApp();
          initAnalytics();
          setupCTALinks();
          updateLinksOnLoad();
          logger.log('[Init] Initialization complete');
        } catch (error) {
          logger.error('[Init] Initialization error:', error);
        }
      }

      // ALWAYS use window.load to ensure everything is ready (like test page)
      const loadHandler = function() {
        logger.log('[Init] window.load event - starting init');
        try {
          init();
        } catch (error) {
          logger.error('[Init] Load handler error:', error);
        }
      };
      win.addEventListener('load', loadHandler);
      registerCleanup(function() { win.removeEventListener('load', loadHandler); });
    })();
  </script>
</head>
<body>
  <!-- Loading Screen (shows in Telegram Mini App only by default) -->
  <LoadingScreen />
  
  <!-- Skip to main content link for accessibility -->
  <a href="#main-content" class="skip-to-main">
    Перейти к основному содержимому
  </a>
  
  <main id="main-content">
    <slot />
  </main>
  
  <!-- TEMPORARY: BackButton Debug Panel (will be removed later) -->
  <div id="backbutton-debug-panel" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.95); color: #0f0; font-family: 'Courier New', monospace; font-size: 11px; z-index: 999999; max-height: 50vh; border-top: 2px solid #0f0; box-shadow: 0 -4px 20px rgba(0, 255, 0, 0.3); user-select: text; -webkit-user-select: text; touch-action: pan-y;">
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(0, 50, 0, 0.5); border-bottom: 1px solid #0f0; flex-wrap: wrap; gap: 8px;">
      <strong style="color: #0ff; font-size: 12px; user-select: none;">🔧 BackButton Debug Panel</strong>
      <div style="display: flex; gap: 6px; flex-wrap: wrap;">
        <button id="backbutton-debug-copy" style="background: #008; color: #fff; border: 1px solid #0ff; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-size: 11px; min-height: 32px; touch-action: manipulation;">📋 Copy Logs</button>
        <button id="backbutton-debug-clear" style="background: #800; color: #fff; border: 1px solid #f00; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-size: 11px; min-height: 32px; touch-action: manipulation;">🗑️ Clear</button>
        <button id="backbutton-debug-toggle" style="background: #080; color: #fff; border: 1px solid #0f0; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-size: 11px; min-height: 32px; touch-action: manipulation;">▼ Hide</button>
      </div>
    </div>
    <div id="backbutton-debug-content" style="padding: 8px 12px; max-height: calc(50vh - 50px); overflow-y: auto; overflow-x: hidden; line-height: 1.5; word-wrap: break-word; -webkit-overflow-scrolling: touch;">
      <div style="color: #0ff; margin-bottom: 8px;">Waiting for logs...</div>
    </div>
  </div>
  
  <!-- Telegram WebApp initialization script - MUST be at end of body -->
  <script is:inline>
    (function() {
      const win = window;
      const doc = document;
      
      // Production-safe logger (fallback if not defined in head)
      if (!win.logger) {
        const isDev = win.location.hostname === 'localhost' || win.location.hostname === '127.0.0.1' || win.location.hostname.includes('.ngrok.io') || win.location.hostname.includes('.trycloudflare.com');
        win.logger = {
          log: function(...args) { if (isDev) console.log(...args); },
          warn: function(...args) { if (isDev) console.warn(...args); },
          error: function(...args) { console.error(...args); }
        };
      }
      const logger = win.logger;
      
      // Cleanup registry (local to this script)
      const cleanupFunctions = [];
      function registerCleanup(fn) {
        cleanupFunctions.push(fn);
        return function() {
          const index = cleanupFunctions.indexOf(fn);
          if (index > -1) cleanupFunctions.splice(index, 1);
        };
      }
      
      // Cleanup on unload
      win.addEventListener('beforeunload', function() {
        cleanupFunctions.forEach(function(fn) { try { fn(); } catch (e) {} });
        cleanupFunctions.length = 0;
      });
      
      // CRITICAL: Check if we should show loading screen immediately (from navigation)
      // This prevents content flash when navigating between pages
      // Note: Don't remove sessionStorage here - LoadingScreen will handle it
      const shouldShowLoader = sessionStorage.getItem('showLoadingScreen') === 'true';
      if (shouldShowLoader) {
        const loadingScreen = doc.getElementById('loading-screen');
        if (loadingScreen) {
          loadingScreen.style.display = 'flex';
          loadingScreen.style.visibility = 'visible';
          loadingScreen.style.pointerEvents = 'auto';
          loadingScreen.style.opacity = '1';
        }
        // Keep main-content hidden until loader hides
        const mainContent = doc.getElementById('main-content');
        if (mainContent) {
          mainContent.style.visibility = 'hidden';
          mainContent.style.opacity = '0';
        }
      } else {
        // Only show main-content if not navigating (first page load or direct URL)
        const mainContent = doc.getElementById('main-content');
        if (mainContent) {
          // LoadingScreen script will handle visibility for Telegram
          // For browser, show immediately if not in Telegram
          const isInTelegram = !!(win.Telegram && win.Telegram.WebApp);
          if (!isInTelegram) {
            mainContent.style.visibility = 'visible';
            mainContent.style.display = 'block';
            mainContent.style.opacity = '1';
          }
        }
      }
      
      // Check if in Telegram (immediate check)
      const isInTelegram = !!(win.Telegram && win.Telegram.WebApp);
      
      // Add class immediately if in Telegram (for CSS to work)
      if (isInTelegram) {
        doc.body.classList.add('tg-webapp');
        
        // Prevent text selection and copying immediately
        function preventSelection(e) {
          if (e.target && e.target.closest && e.target.closest('input, textarea')) {
            return; // Allow selection in inputs
          }
          e.preventDefault();
          return false;
        }
        
        function preventCopy(e) {
          if (e.target && e.target.closest && e.target.closest('input, textarea')) {
            return; // Allow copy in inputs
          }
          e.preventDefault();
          e.clipboardData.clearData();
          return false;
        }
        
        function preventContextMenu(e) {
          if (e.target && e.target.closest && e.target.closest('input, textarea')) {
            return; // Allow context menu in inputs
          }
          e.preventDefault();
          return false;
        }
        
        // Add event listeners to prevent selection/copy
        doc.addEventListener('selectstart', preventSelection, { passive: false });
        doc.addEventListener('copy', preventCopy, { passive: false });
        doc.addEventListener('contextmenu', preventContextMenu, { passive: false });
        
        // CSS fallback for user-select (more robust)
        const style = doc.createElement('style');
        style.textContent = `
          body.tg-webapp, body.tg-webapp * {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
          }
          body.tg-webapp input,
          body.tg-webapp textarea {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
          }
        `;
        doc.head.appendChild(style);
      }
      
      // Wait for Telegram WebApp to be available
      function initTelegramApp() {
        // Ensure logger is available (use closure logger or win.logger as fallback)
        const initLogger = logger || win.logger || {
          log: function() {},
          warn: function() {},
          error: function() { console.error(...arguments); }
        };
        
        if (!win.Telegram?.WebApp) {
          // Retry for up to 5 seconds
          if (typeof initTelegramApp.retries === 'undefined') {
            initTelegramApp.retries = 0;
          }
          if (initTelegramApp.retries < 100) {
            initTelegramApp.retries++;
            setTimeout(initTelegramApp, 50);
          }
          return;
        }
        
        const tg = win.Telegram.WebApp;
        initLogger.log('[TG] Initializing v' + tg.version + ' on ' + tg.platform);
        
        // Ensure class is added (double-check)
        if (!doc.body.classList.contains('tg-webapp')) {
          doc.body.classList.add('tg-webapp');
        }
        
        // Initialize
        tg.ready();
        tg.expand();
        tg.enableClosingConfirmation();
        
        // Update CSS variables with Telegram viewport data
        if (tg.viewportHeight) {
          doc.documentElement.style.setProperty('--tg-viewport-height', tg.viewportHeight + 'px');
        }
        if (tg.viewportStableHeight) {
          doc.documentElement.style.setProperty('--tg-viewport-stable-height', tg.viewportStableHeight + 'px');
        }
        
        // Update safe area insets if available
        if (tg.safeAreaInset) {
          doc.documentElement.style.setProperty('--tg-safe-area-inset-top', tg.safeAreaInset.top + 'px');
          doc.documentElement.style.setProperty('--tg-safe-area-inset-bottom', tg.safeAreaInset.bottom + 'px');
          doc.documentElement.style.setProperty('--tg-safe-area-inset-left', tg.safeAreaInset.left + 'px');
          doc.documentElement.style.setProperty('--tg-safe-area-inset-right', tg.safeAreaInset.right + 'px');
        }
        
        // Listen for viewport changes
        tg.onEvent('viewportChanged', () => {
          if (tg.viewportHeight) {
            doc.documentElement.style.setProperty('--tg-viewport-height', tg.viewportHeight + 'px');
          }
          if (tg.viewportStableHeight) {
            doc.documentElement.style.setProperty('--tg-viewport-stable-height', tg.viewportStableHeight + 'px');
          }
        });
        
        // Bot API 7.7+: Disable vertical swipes
        if (typeof tg.disableVerticalSwipes === 'function') {
          tg.disableVerticalSwipes();
        }
        
        // Ensure logger is available for this scope (BEFORE using it)
        const hapticLogger = logger || win.logger || {
          log: function() {},
          warn: function() {},
          error: function() { console.error(...arguments); }
        };
        
        // Bot API 8.0+: Request fullscreen
        if (typeof tg.requestFullscreen === 'function') {
          try {
            tg.requestFullscreen();
          } catch (err) {
            hapticLogger.warn('[TG] Fullscreen error:', err);
          }
        }
        
        // Setup haptics for interactive elements (excluding CTA links - handled separately)
        const haptics = tg.HapticFeedback;
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        
        // Always setup haptics if available (even if not touch device - for desktop Telegram)
        if (haptics) {
          // Function to add haptic to element
          function addHapticToElement(el) {
            if (!el || el.hasAttribute('data-haptic-attached')) return;
            
            el.setAttribute('data-haptic-attached', 'true');
            
            // Light haptic on touchstart (with rate limiting) - for touch devices
            if (isTouchDevice) {
              el.addEventListener('touchstart', function() {
                try {
                  if (rateLimiter.isAllowed() && haptics) {
                    haptics.impactOccurred('light');
                  }
                } catch (e) {
                  // Fallback: try without rate limiter if it fails
                  try {
                    if (haptics) haptics.impactOccurred('light');
                  } catch (e2) {}
                }
              }, { passive: true });
            }
            
            // Selection haptic on pointerenter (for desktop Telegram)
            el.addEventListener('pointerenter', function() {
              try {
                if (haptics && !isTouchDevice) {
                  haptics.selectionChanged();
                }
              } catch (e) {}
            }, { passive: true });
          }
          
          // Rate limiter for haptics (prevents spam) - more lenient
          const rateLimiter = (function() {
            const requests = new Map();
            const maxRequests = 200; // Increased from 100
            const windowMs = 1000;
            
            function isAllowed() {
              try {
                const now = Date.now();
                const key = 'haptics';
                let record = requests.get(key);
                
                if (!record) {
                  record = { timestamps: [] };
                  requests.set(key, record);
                }
                
                // Remove old timestamps
                record.timestamps = record.timestamps.filter(ts => now - ts < windowMs);
                
                if (record.timestamps.length < maxRequests) {
                  record.timestamps.push(now);
                  return true;
                }
                
                return false;
              } catch (e) {
                // If rate limiter fails, allow haptic anyway
                return true;
              }
            }
            
            return { isAllowed };
          })();
          
          // DOM cache for haptic elements (optimize repeated queries)
          const hapticCache = new Map();
          
          // Function to setup haptics for elements (with retry for dynamic content)
          function setupHapticsForElements() {
            if (!hapticCache) return; // Safety check
            const clickableSelectors = [
              'button:not([data-cta]):not(.btn-capsule)',
              'a[href]:not([data-cta])',
              '[role="button"]:not([data-cta])',
              '.proof-item',
              '.proof-image-placeholder',
              '.student-photo',
              '.student-circle',
              '.banner-photo',
              '.models-banner > div',
              '.step-card',
              '.system-step',
              '.benefit-item',
              '.timeline-step',
              '.step-marker',
              '.founder-avatar',
              '.photo-circle',
              '.earning-corner'
            ];
            
            clickableSelectors.forEach(selector => {
              try {
                // Use cache if available
                let elements = hapticCache.get(selector);
                const cacheTime = hapticCache.get(selector + ':time') || 0;
                const now = Date.now();
                
                // Cache for 2 seconds
                if (!elements || (now - cacheTime) > 2000) {
                  elements = doc.querySelectorAll(selector);
                  hapticCache.set(selector, elements);
                  hapticCache.set(selector + ':time', now);
                }
                
                elements.forEach(el => {
                  addHapticToElement(el);
                });
              } catch (e) {
                hapticLogger.warn('[TG] Haptic setup error for selector:', selector, e);
              }
            });
          }
          
          // Setup immediately
          setupHapticsForElements();
          
          // Retry after delays (for dynamic content that loads later)
          const timeout1 = setTimeout(setupHapticsForElements, 300);
          const timeout2 = setTimeout(setupHapticsForElements, 1000);
          const timeout3 = setTimeout(setupHapticsForElements, 2000);
          registerCleanup(function() {
            clearTimeout(timeout1);
            clearTimeout(timeout2);
            clearTimeout(timeout3);
          });
          
          // Event delegation as fallback (catches any missed elements)
          const delegationHandler = function(e) {
            if (!haptics) return;
            
            const target = e.target;
            // Fix: Check if target is a DOM element before calling closest()
            if (!target || typeof target.closest !== 'function') return;
            
            // Check if touched element is one of our interactive elements
            const isInteractive = target.closest('.proof-item, .proof-image-placeholder, .student-photo, .student-circle, .banner-photo, .models-banner > div, .step-card, .benefit-item, .timeline-step, .founder-avatar, .photo-circle, .earning-corner, button, a[href], [role="button"]');
            
            if (isInteractive) {
              // Skip if already has direct listener (avoid double haptic)
              if (isInteractive.hasAttribute('data-haptic-attached')) {
                return; // Direct listener will handle it
              }
              
              // Add to element if not already added
              addHapticToElement(isInteractive);
              
              // Trigger haptic immediately via delegation (only for elements without direct listener)
              try {
                if (isTouchDevice && rateLimiter.isAllowed()) {
                  haptics.impactOccurred('light');
                } else if (!isTouchDevice) {
                  haptics.selectionChanged();
                }
              } catch (err) {
                // Fallback: try without rate limiter
                try {
                  if (haptics) {
                    if (isTouchDevice) {
                      haptics.impactOccurred('light');
                    } else {
                      haptics.selectionChanged();
                    }
                  }
                } catch (e2) {}
              }
            }
          };
          const delegationOpts = { passive: true, capture: true }; // Changed to capture phase
          doc.addEventListener('touchstart', delegationHandler, delegationOpts);
          if (!isTouchDevice) {
            doc.addEventListener('pointerenter', delegationHandler, delegationOpts);
          }
          registerCleanup(function() {
            doc.removeEventListener('touchstart', delegationHandler, delegationOpts);
            doc.removeEventListener('pointerenter', delegationHandler, delegationOpts);
          });
          
          // Medium haptic on click for buttons (non-CTA) - use cached query
          if (hapticCache) {
            let buttonElements = hapticCache.get('button:not([data-cta]):not(.btn-capsule), [role="button"]:not([data-cta])');
            if (!buttonElements) {
              buttonElements = doc.querySelectorAll('button:not([data-cta]):not(.btn-capsule), [role="button"]:not([data-cta])');
              hapticCache.set('button:not([data-cta]):not(.btn-capsule), [role="button"]:not([data-cta])', buttonElements);
            }
            buttonElements.forEach(function(el) {
              const clickHandler = function() {
                try {
                  if (rateLimiter.isAllowed()) {
                    haptics.impactOccurred('medium');
                  }
                } catch (e) {}
              };
              el.addEventListener('click', clickHandler);
              registerCleanup(function() {
                el.removeEventListener('click', clickHandler);
              });
            });
          }
        }
        
        // Expose global haptics helper (always available)
        if (haptics) {
          win.triggerHaptic = (type = 'medium') => {
            try {
              if (type === 'selection') haptics.selectionChanged();
              else if (type === 'success') haptics.notificationOccurred('success');
              else if (type === 'warning') haptics.notificationOccurred('warning');
              else if (type === 'error') haptics.notificationOccurred('error');
              else haptics.impactOccurred(type);
            } catch (e) {}
          };
        }
        
        hapticLogger.log('[TG] ✅ Ready');
        
        // Setup touch events for interactive elements (replace hover)
        // Visual feedback for touch interactions
        if (isTouchDevice) {
          // Use cached query if available
          const touchSelector = '.reveal-up, .proof-item, .proof-image-placeholder, .student-photo, .student-circle, .banner-photo, .models-banner > div, .step-card, .path-card, .format-card, .cta-section, button, a[data-cta], .btn-capsule, .timeline-step';
          let touchElements = hapticCache ? hapticCache.get(touchSelector) : null;
          if (!touchElements) {
            touchElements = doc.querySelectorAll(touchSelector);
            if (hapticCache) {
              hapticCache.set(touchSelector, touchElements);
            }
          }
          const touchOpts = { passive: true };
          
          touchElements.forEach(function(el) {
            const touchStartHandler = function() {
              this.classList.add('touch-active');
            };
            const touchEndHandler = function() {
              const self = this;
              const timeout = setTimeout(function() {
                self.classList.remove('touch-active');
              }, 150);
              registerCleanup(function() { clearTimeout(timeout); });
            };
            const touchCancelHandler = function() {
              this.classList.remove('touch-active');
            };
            
            el.addEventListener('touchstart', touchStartHandler, touchOpts);
            el.addEventListener('touchend', touchEndHandler, touchOpts);
            el.addEventListener('touchcancel', touchCancelHandler, touchOpts);
            
            registerCleanup(function() {
              el.removeEventListener('touchstart', touchStartHandler, touchOpts);
              el.removeEventListener('touchend', touchEndHandler, touchOpts);
              el.removeEventListener('touchcancel', touchCancelHandler, touchOpts);
            });
          });
        }
      }
      
      // Start initialization
      initTelegramApp();
    })();
  </script>
  
  <!-- Touch interaction styles for Telegram -->
  <style>
    /* Touch feedback for all interactive elements (Telegram only) */
    body.tg-webapp .touch-active {
      transform: scale(0.97) translateZ(0);
      opacity: 0.85;
      transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: transform, opacity;
    }
    
    /* Enhanced touch feedback for buttons (Telegram only) */
    body.tg-webapp button.touch-active,
    body.tg-webapp .btn-capsule.touch-active,
    body.tg-webapp a[data-cta].touch-active {
      transform: scale(0.95) translateZ(0);
      opacity: 0.9;
      will-change: transform, opacity;
    }
    
    /* Disable hover effects in Telegram (they don't work) */
    body.tg-webapp *:hover {
      transform: none !important;
    }
    
    body.tg-webapp .reveal-up:hover,
    body.tg-webapp .proof-item:hover,
    body.tg-webapp .step-card:hover,
    body.tg-webapp .btn-capsule:hover,
    body.tg-webapp button:hover,
    body.tg-webapp a:hover {
      transform: none !important;
      box-shadow: none !important;
    }
    
    /* Better touch targets for Telegram */
    body.tg-webapp button,
    body.tg-webapp a[href],
    body.tg-webapp .btn-capsule {
      min-height: 44px;
      min-width: 44px;
    }
    
    /* Optimize reveal animations for Telegram (better performance) */
    body.tg-webapp .reveal-fade,
    body.tg-webapp .reveal-up,
    body.tg-webapp .reveal-scale {
      will-change: opacity, transform;
      transform: translateZ(0);
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
    }
    
    body.tg-webapp .reveal-fade.is-revealed,
    body.tg-webapp .reveal-up.is-revealed,
    body.tg-webapp .reveal-scale.is-revealed {
      will-change: auto;
    }
    
    /* Force hardware acceleration for smooth animations in Telegram */
    body.tg-webapp .reveal-up {
      transform: translateY(20px) translateZ(0);
    }
    
    body.tg-webapp .reveal-up.is-revealed {
      transform: translateY(0) translateZ(0);
    }
    
    body.tg-webapp .reveal-scale {
      transform: scale(0.95) translateZ(0);
    }
    
    body.tg-webapp .reveal-scale.is-revealed {
      transform: scale(1) translateZ(0);
    }
    
    /* Prevent animation jank during scroll in Telegram */
    body.tg-webapp {
      -webkit-overflow-scrolling: touch;
      overflow-scrolling: touch;
    }
  </style>
  
  <!-- TEMPORARY: BackButton Debug Panel Script (will be removed later) -->
  <script is:inline>
    (function() {
      'use strict';
      
      const panel = document.getElementById('backbutton-debug-panel');
      const content = document.getElementById('backbutton-debug-content');
      const copyBtn = document.getElementById('backbutton-debug-copy');
      const clearBtn = document.getElementById('backbutton-debug-clear');
      const toggleBtn = document.getElementById('backbutton-debug-toggle');
      
      if (!panel || !content) return;
      
      // Show panel immediately
      panel.style.display = 'block';
      
      const logs = [];
      const maxLogs = 200; // Limit to prevent memory issues
      let isCollapsed = false;
      
      // Function to add log entry
      function addLog(message, type) {
        type = type || 'info';
        const timestamp = new Date().toLocaleTimeString('ru-RU', { 
          hour12: false, 
          hour: '2-digit', 
          minute: '2-digit', 
          second: '2-digit',
          fractionalSecondDigits: 3
        });
        
        const colors = {
          info: '#0f0',
          success: '#0ff',
          warn: '#ff0',
          error: '#f00',
          event: '#f0f'
        };
        
        const color = colors[type] || colors.info;
        const icon = type === 'error' ? '❌' : type === 'warn' ? '⚠️' : type === 'success' ? '✅' : type === 'event' ? '🔔' : 'ℹ️';
        
        const logEntry = {
          timestamp,
          message: String(message),
          type,
          color,
          icon
        };
        
        logs.push(logEntry);
        
        // Limit logs
        if (logs.length > maxLogs) {
          logs.shift();
        }
        
        updateDisplay();
      }
      
      // Update display
      function updateDisplay() {
        if (isCollapsed) return;
        
        const recentLogs = logs.slice(-50); // Show last 50 logs
        content.innerHTML = recentLogs.map(function(log) {
          return '<div style="color: ' + log.color + '; margin-bottom: 2px; padding: 2px 0; border-bottom: 1px solid rgba(0,255,0,0.1);">' +
            '<span style="color: #888; font-size: 9px;">[' + log.timestamp + ']</span> ' + log.icon + ' ' + log.message +
          '</div>';
        }).join('');
        
        // Auto-scroll to bottom
        content.scrollTop = content.scrollHeight;
      }
      
      // Copy logs to clipboard
      function copyLogs() {
        try {
          const logText = logs.map(function(log) {
            return '[' + log.timestamp + '] ' + log.icon + ' ' + log.message;
          }).join('\n');
          
          // Use Clipboard API (modern browsers)
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(logText).then(function() {
              copyBtn.textContent = '✅ Copied!';
              copyBtn.style.background = '#080';
              setTimeout(function() {
                copyBtn.textContent = '📋 Copy Logs';
                copyBtn.style.background = '#008';
              }, 2000);
            }).catch(function(err) {
              console.error('Failed to copy logs:', err);
              copyBtn.textContent = '❌ Error';
              copyBtn.style.background = '#800';
              setTimeout(function() {
                copyBtn.textContent = '📋 Copy Logs';
                copyBtn.style.background = '#008';
              }, 2000);
            });
            return;
          } else {
            // Fallback for older browsers
            const textarea = document.createElement('textarea');
            textarea.value = logText;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            copyBtn.textContent = '✅ Copied!';
            copyBtn.style.background = '#080';
            setTimeout(function() {
              copyBtn.textContent = '📋 Copy Logs';
              copyBtn.style.background = '#008';
            }, 2000);
          }
        } catch (err) {
          console.error('Failed to copy logs:', err);
          copyBtn.textContent = '❌ Error';
          copyBtn.style.background = '#800';
          setTimeout(function() {
            copyBtn.textContent = '📋 Copy Logs';
            copyBtn.style.background = '#008';
          }, 2000);
        }
      }
      
      // Clear logs
      function clearLogs() {
        logs.length = 0;
        content.innerHTML = '<div style="color: #0ff;">Logs cleared...</div>';
      }
      
      // Toggle collapse
      function toggleCollapse() {
        isCollapsed = !isCollapsed;
        if (isCollapsed) {
          content.style.display = 'none';
          toggleBtn.textContent = '▲ Show';
          panel.style.maxHeight = '50px';
        } else {
          content.style.display = 'block';
          toggleBtn.textContent = '▼ Hide';
          panel.style.maxHeight = '50vh';
          updateDisplay();
        }
      }
      
      // Event listeners
      copyBtn.addEventListener('click', copyLogs);
      clearBtn.addEventListener('click', clearLogs);
      toggleBtn.addEventListener('click', toggleCollapse);
      
      // Load logs from early interception (before this script ran)
      if (window._backbuttonDebugLogs && window._backbuttonDebugLogs.length > 0) {
        window._backbuttonDebugLogs.forEach(function(log) {
          addLog(log.message, log.type);
        });
        addLog('Loaded ' + window._backbuttonDebugLogs.length + ' logs from early interception', 'success');
      }
      
      // Continue intercepting new logs
      // Intercept logger calls for [TG-BackButton] prefix
      const originalLogger = window.logger;
      if (originalLogger) {
        const originalLog = originalLogger.log;
        const originalWarn = originalLogger.warn;
        const originalError = originalLogger.error;
        
        originalLogger.log = function(...args) {
          const message = args.map(function(a) { return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); }).join(' ');
          if (message.includes('[TG-BackButton]')) {
            addLog(message, 'info');
            // Also store in early log storage
            if (window._backbuttonDebugLogs) {
              window._backbuttonDebugLogs.push({
                timestamp: new Date().toLocaleTimeString('ru-RU', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 }),
                message: message,
                type: 'info'
              });
            }
          }
          originalLog.apply(originalLogger, args);
        };
        
        originalLogger.warn = function(...args) {
          const message = args.map(function(a) { return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); }).join(' ');
          if (message.includes('[TG-BackButton]')) {
            addLog(message, 'warn');
            if (window._backbuttonDebugLogs) {
              window._backbuttonDebugLogs.push({
                timestamp: new Date().toLocaleTimeString('ru-RU', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 }),
                message: message,
                type: 'warn'
              });
            }
          }
          originalWarn.apply(originalLogger, args);
        };
        
        originalLogger.error = function(...args) {
          const message = args.map(function(a) { return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); }).join(' ');
          if (message.includes('[TG-BackButton]')) {
            addLog(message, 'error');
            if (window._backbuttonDebugLogs) {
              window._backbuttonDebugLogs.push({
                timestamp: new Date().toLocaleTimeString('ru-RU', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 }),
                message: message,
                type: 'error'
              });
            }
          }
          originalError.apply(originalLogger, args);
        };
      }
      
      // Also intercept console methods for [TG-BackButton]
      const originalConsoleLog = console.log;
      const originalConsoleWarn = console.warn;
      const originalConsoleError = console.error;
      
      console.log = function(...args) {
        const message = args.map(function(a) { return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); }).join(' ');
        if (message.includes('[TG-BackButton]')) {
          addLog(message, 'info');
        }
        originalConsoleLog.apply(console, args);
      };
      
      console.warn = function(...args) {
        const message = args.map(function(a) { return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); }).join(' ');
        if (message.includes('[TG-BackButton]')) {
          addLog(message, 'warn');
        }
        originalConsoleWarn.apply(console, args);
      };
      
      console.error = function(...args) {
        const message = args.map(function(a) { return typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a); }).join(' ');
        if (message.includes('[TG-BackButton]')) {
          addLog(message, 'error');
        }
        originalConsoleError.apply(console, args);
      };
      
      // Initial message
      addLog('BackButton Debug Panel initialized', 'success');
      addLog('Monitoring [TG-BackButton] logs...', 'info');
      addLog('Total logs in early storage: ' + (window._backbuttonDebugLogs ? window._backbuttonDebugLogs.length : 0), 'info');
    })();
  </script>
</body>
</html>

